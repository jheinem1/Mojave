<roblox version="4">
  <Item class="HttpService" referent="0">
    <Properties>
      <string name="Name">HttpService</string>
      <bool name="HttpEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">allies</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local GroupService = _services.GroupService
local ServerScriptService = _services.ServerScriptService
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local Allies
do
	Allies = setmetatable({}, {
		__tostring = function()
			return "Allies"
		end,
	})
	Allies.__index = Allies
	function Allies.new(...)
		local self = setmetatable({}, Allies)
		return self:constructor(...) or self
	end
	function Allies:constructor()
	end
	function Allies:refresh()
		local newAllies = {}
		local allyPages = GroupService:GetAlliesAsync(4978642)
		while true do
			local _exp = allyPages:GetCurrentPage()
			local _arg0 = function(group)
				group.Name = self:cleanGroupName(group.Name)
				-- ▼ Array.push ▼
				newAllies[#newAllies + 1] = group
				-- ▲ Array.push ▲
			end
			-- ▼ ReadonlyArray.forEach ▼
			for _k, _v in ipairs(_exp) do
				_arg0(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
			if allyPages.IsFinished then
				self.allies = newAllies
				return nil
			else
				allyPages:AdvanceToNextPageAsync()
			end
		end
	end
	function Allies:cleanGroupName(name)
		local outArray = {}
		local i = 1
		local _i = i
		local _i_1 = i
		local char = string.sub(name, _i, _i_1)
		while char ~= "" do
			local _value = char == " " or (string.match(char, "%a"))
			if _value ~= 0 and _value == _value and _value ~= "" and _value then
				local _char = char
				-- ▼ Array.push ▼
				outArray[#outArray + 1] = _char
				-- ▲ Array.push ▲
			end
			i += 1
			local _i_2 = i
			local _i_3 = i
			char = string.sub(name, _i_2, _i_3)
		end
		-- ▼ ReadonlyArray.join ▼
		local _arg0 = ""
		if _arg0 == nil then
			_arg0 = ", "
		end
		-- ▲ ReadonlyArray.join ▲
		local outStr = table.concat(outArray, _arg0)
		local _condition = (string.match(outStr, "^%s*(%a+[%a%s]*%a+)%s*$"))
		if _condition == nil then
			_condition = (string.match(outStr, "^%s*(%a+)%s*$"))
			if _condition == nil then
				_condition = "Invalid Group Name!"
			end
		end
		return _condition
	end
	function Allies:getAllies()
		if not self.allies then
			Allies:refresh()
		end
		return self.allies
	end
end
local _refreshEvent = ServerScriptService:FindFirstChild("Server")
if _refreshEvent ~= nil then
	_refreshEvent = _refreshEvent:FindFirstChild("onjoin")
	if _refreshEvent ~= nil then
		_refreshEvent = _refreshEvent:FindFirstChild("reloadteams")
	end
end
local refreshEvent = _refreshEvent
if t.instanceOf("BindableEvent")(refreshEvent) then
	refreshEvent.Event:Connect(function()
		return Allies:refresh()
	end)
end
local default = Allies
return {
	default = default,
}
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">avatar</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local MarketplaceService = _services.MarketplaceService
local Players = _services.Players
local Workspace = _services.Workspace
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local getR15 = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "avatar", "character_types").getR15
local Avatar
do
	Avatar = setmetatable({}, {
		__tostring = function()
			return "Avatar"
		end,
	})
	Avatar.__index = Avatar
	function Avatar.new(...)
		local self = setmetatable({}, Avatar)
		return self:constructor(...) or self
	end
	function Avatar:constructor(user)
		self.user = user
		self.appearanceInfo = Players:GetCharacterAppearanceInfoAsync(t.number(user) and user or user.UserId)
	end
	function Avatar:loadCharacter()
		local character = getR15()
		character:SetPrimaryPartCFrame(CFrame.new())
		character.HumanoidRootPart.Anchored = true
		character.Parent = Workspace
		character.Humanoid:ApplyDescription(Players:GetHumanoidDescriptionFromUserId(t.number(self.user) and self.user or self.user.UserId))
		character.Parent = nil
		return character
	end
	function Avatar:changeShirt(character, newShirtId)
		local productInfo = MarketplaceService:GetProductInfo(newShirtId, Enum.InfoType.Asset)
		local _exp = productInfo.AssetTypeId == Enum.AssetType.Image.Value
		local _exp_1 = Enum.AssetType:GetEnumItems()
		local _arg0 = function(assetType)
			return assetType.Value == productInfo.AssetTypeId
		end
		-- ▼ ReadonlyArray.find ▼
		local _result = nil
		for _i, _v in ipairs(_exp_1) do
			if _arg0(_v, _i - 1, _exp_1) == true then
				_result = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		local _arg1 = 'Expected image, got "' .. tostring(_result) .. [[" from ']] .. tostring(newShirtId) .. "'"
		assert(_exp, _arg1)
		-- const newShirt = new Instance("Shirt");
		-- newShirt.ShirtTemplate = `rbxassetid://${productInfo.AssetId}`;
		-- character.Shirt?.Destroy();
		-- newShirt.Parent = character;
		if character.Humanoid.HumanoidDescription then
			character.Humanoid.HumanoidDescription.Shirt = productInfo.AssetId
			local oldParent = character.Parent
			character.Parent = Workspace
			character.Humanoid:ApplyDescription(character.Humanoid.HumanoidDescription)
			character.Parent = oldParent
		end
		return character
	end
	function Avatar:changePants(character, newPantsId)
		local productInfo = MarketplaceService:GetProductInfo(newPantsId, Enum.InfoType.Asset)
		local _exp = productInfo.AssetTypeId == Enum.AssetType.Image.Value
		local _exp_1 = Enum.AssetType:GetEnumItems()
		local _arg0 = function(assetType)
			return assetType.Value == productInfo.AssetTypeId
		end
		-- ▼ ReadonlyArray.find ▼
		local _result = nil
		for _i, _v in ipairs(_exp_1) do
			if _arg0(_v, _i - 1, _exp_1) == true then
				_result = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		local _arg1 = 'Expected image, got "' .. tostring(_result) .. [[" from ']] .. tostring(newPantsId) .. "'"
		assert(_exp, _arg1)
		-- const newPants = new Instance("Pants");
		-- newPants.PantsTemplate = `rbxassetid://${productInfo.AssetId}`;
		-- character.Pants?.Destroy();
		-- newPants.Parent = character;
		if character.Humanoid.HumanoidDescription then
			character.Humanoid.HumanoidDescription.Pants = productInfo.AssetId
			local oldParent = character.Parent
			character.Parent = Workspace
			character.Humanoid:ApplyDescription(character.Humanoid.HumanoidDescription)
			character.Parent = oldParent
		end
		return character
	end
	function Avatar:loadCharacterR6()
		error("Method not implemented")
		-- const character = getR6();
		-- return character;
	end
end
return {
	Avatar = Avatar,
}
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="5">
          <Properties>
            <string name="Name">character_types</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local function getR6()
	local _result = script.Parent
	if _result ~= nil then
		_result = _result:FindFirstChild("models")
		if _result ~= nil then
			_result = _result:FindFirstChild("R6")
		end
	end
	local character = _result
	if character then
		return character:Clone()
	else
		error("Rig not found!")
	end
end
local function getR15()
	local _result = script.Parent
	if _result ~= nil then
		_result = _result:FindFirstChild("models")
		if _result ~= nil then
			_result = _result:FindFirstChild("R15")
		end
	end
	local character = _result
	if character then
		return character:Clone()
	else
		error("Rig not found!")
	end
end
return {
	getR6 = getR6,
	getR15 = getR15,
}
]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="6">
          <Properties>
            <string name="Name">models</string>
          </Properties>
          <Item class="Model" referent="7">
            <Properties>
              <string name="Name">R15</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <bool name="NeedsPivotMigration">false</bool>
              <Ref name="PrimaryPart">8</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="8">
              <Properties>
                <string name="Name">HumanoidRootPart</string>
                <bool name="Anchored">true</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">4</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">3</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="9">
                <Properties>
                  <string name="Name">RootRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="10">
              <Properties>
                <string name="Name">LeftHand</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-17.899857</X>
                  <Y>2.1495194</Y>
                  <Z>-11.100351</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999997615814209</X>
                  <Y>0.29999998211860657</Y>
                  <Z>0.9999998807907104</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532219986</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999997615814209</X>
                  <Y>0.29999998211860657</Y>
                  <Z>0.9999998807907104</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="11">
                <Properties>
                  <string name="Name">LeftWristRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.00047886372</X>
                    <Y>0.14999999</Y>
                    <Z>0.000000059604645</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="12">
                <Properties>
                  <string name="Name">LeftGripAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.00000011920929</X>
                    <Y>-0.14999963</Y>
                    <Z>-0.00000014630612</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>0.00000000000000006123234</R11>
                    <R12>1</R12>
                    <R20>0</R20>
                    <R21>-1</R21>
                    <R22>0.00000000000000006123234</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="13">
                <Properties>
                  <string name="Name">LeftWrist</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0.0004785061</X>
                    <Y>-0.54999995</Y>
                    <Z>0.000000000000000000076446255</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.00047886372</X>
                    <Y>0.14999999</Y>
                    <Z>0.000000059604645</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">14</Ref>
                  <Ref name="Part1">10</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="14">
              <Properties>
                <string name="Name">LeftLowerArm</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-17.899857</X>
                  <Y>2.8495195</Y>
                  <Z>-11.100351</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999997615814209</X>
                  <Y>1.200000286102295</Y>
                  <Z>1</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532219991</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999997615814209</X>
                  <Y>1.200000286102295</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="15">
                <Properties>
                  <string name="Name">LeftElbowRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.0004785061</X>
                    <Y>0.25000003</Y>
                    <Z>0.000000000000000000076446255</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="16">
                <Properties>
                  <string name="Name">LeftWristRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.0004785061</X>
                    <Y>-0.54999995</Y>
                    <Z>0.000000000000000000076446255</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="17">
                <Properties>
                  <string name="Name">LeftElbow</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0.00047910213</X>
                    <Y>-0.20000017</Y>
                    <Z>0.00000008940697</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.0004785061</X>
                    <Y>0.25000003</Y>
                    <Z>0.000000000000000000076446255</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">18</Ref>
                  <Ref name="Part1">14</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="18">
              <Properties>
                <string name="Name">LeftUpperArm</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-17.899857</X>
                  <Y>3.2995198</Y>
                  <Z>-11.100351</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999997615814209</X>
                  <Y>1.4000003337860107</Y>
                  <Z>0.9999999403953552</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532219996</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999997615814209</X>
                  <Y>1.4000003337860107</Y>
                  <Z>0.9999999403953552</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="19">
                <Properties>
                  <string name="Name">LeftShoulderRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.2501092</X>
                    <Y>0.4499998</Y>
                    <Z>0.00000008940697</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="20">
                <Properties>
                  <string name="Name">LeftElbowRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.00047910213</X>
                    <Y>-0.20000017</Y>
                    <Z>0.00000008940697</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="21">
                <Properties>
                  <string name="Name">LeftShoulderAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.00000023841858</X>
                    <Y>0.7000003</Y>
                    <Z>-0.000000027096831</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="22">
                <Properties>
                  <string name="Name">LeftShoulder</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>-1.2498913</X>
                    <Y>0.54999995</Y>
                    <Z>0.00000011920929</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.2501092</X>
                    <Y>0.4499998</Y>
                    <Z>0.00000008940697</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">23</Ref>
                  <Ref name="Part1">18</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="24">
              <Properties>
                <string name="Name">RightHand</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-14.899857</X>
                  <Y>2.1495194</Y>
                  <Z>-11.100346</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999998807907104</X>
                  <Y>0.29999998211860657</Y>
                  <Z>0.9999998807907104</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532219997</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999998807907104</X>
                  <Y>0.29999998211860657</Y>
                  <Z>0.9999998807907104</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="25">
                <Properties>
                  <string name="Name">RightWristRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.00000035762787</X>
                    <Y>0.14999999</Y>
                    <Z>0.000000059604645</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="26">
                <Properties>
                  <string name="Name">RightGripAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-0.14999963</Y>
                    <Z>-0.00000014630612</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>0.00000000000000006123234</R11>
                    <R12>1</R12>
                    <R20>0</R20>
                    <R21>-1</R21>
                    <R22>0.00000000000000006123234</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="27">
                <Properties>
                  <string name="Name">RightWrist</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0.00000011920929</X>
                    <Y>-0.54999995</Y>
                    <Z>-0.0000000000000000068624475</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.00000035762787</X>
                    <Y>0.14999999</Y>
                    <Z>0.000000059604645</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">28</Ref>
                  <Ref name="Part1">24</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="28">
              <Properties>
                <string name="Name">RightLowerArm</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-14.899857</X>
                  <Y>2.8495195</Y>
                  <Z>-11.100346</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999997615814209</X>
                  <Y>1.200000286102295</Y>
                  <Z>1</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532219999</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999997615814209</X>
                  <Y>1.200000286102295</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="29">
                <Properties>
                  <string name="Name">RightElbowRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.00000011920929</X>
                    <Y>0.25000003</Y>
                    <Z>0.000000000000000000076446255</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="30">
                <Properties>
                  <string name="Name">RightWristRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.00000011920929</X>
                    <Y>-0.54999995</Y>
                    <Z>-0.0000000000000000068624475</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="31">
                <Properties>
                  <string name="Name">RightElbow</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>-0.00000059604645</X>
                    <Y>-0.20000017</Y>
                    <Z>0.00000008940697</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.00000011920929</X>
                    <Y>0.25000003</Y>
                    <Z>0.000000000000000000076446255</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">32</Ref>
                  <Ref name="Part1">28</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="32">
              <Properties>
                <string name="Name">RightUpperArm</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-14.899856</X>
                  <Y>3.2995198</Y>
                  <Z>-11.100346</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999996423721313</X>
                  <Y>1.4000003337860107</Y>
                  <Z>0.9999999403953552</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220004</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999996423721313</X>
                  <Y>1.4000003337860107</Y>
                  <Z>0.9999999403953552</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="33">
                <Properties>
                  <string name="Name">RightShoulderRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.25002027</X>
                    <Y>0.4499998</Y>
                    <Z>0.00000008940697</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="34">
                <Properties>
                  <string name="Name">RightElbowRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.00000059604645</X>
                    <Y>-0.20000017</Y>
                    <Z>0.00000008940697</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="35">
                <Properties>
                  <string name="Name">RightShoulderAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.0000009536743</X>
                    <Y>0.7000003</Y>
                    <Z>-0.000000027096831</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="36">
                <Properties>
                  <string name="Name">RightShoulder</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>1.2499804</X>
                    <Y>0.54999995</Y>
                    <Z>0.00000011920929</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.25002027</X>
                    <Y>0.4499998</Y>
                    <Z>0.00000008940697</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">23</Ref>
                  <Ref name="Part1">32</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="23">
              <Properties>
                <string name="Name">UpperTorso</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-16.399857</X>
                  <Y>3.1995196</Y>
                  <Z>-11.100348</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>2</X>
                  <Y>1.6000001430511475</Y>
                  <Z>1.0000003576278687</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220007</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>1.6000001430511475</Y>
                  <Z>1.0000003576278687</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="37">
                <Properties>
                  <string name="Name">WaistRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.000000059604645</X>
                    <Y>-0.45000002</Y>
                    <Z>0.00000011920929</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="38">
                <Properties>
                  <string name="Name">NeckRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.000000059604645</X>
                    <Y>0.79999995</Y>
                    <Z>0.00000011920929</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="39">
                <Properties>
                  <string name="Name">LeftShoulderRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-1.2498913</X>
                    <Y>0.54999995</Y>
                    <Z>0.00000011920929</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="40">
                <Properties>
                  <string name="Name">RightShoulderRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>1.2499804</X>
                    <Y>0.54999995</Y>
                    <Z>0.00000011920929</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="41">
                <Properties>
                  <string name="Name">BodyFrontAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.000000059604645</X>
                    <Y>-0.20000005</Y>
                    <Z>-0.49999988</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="42">
                <Properties>
                  <string name="Name">BodyBackAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.000000059604645</X>
                    <Y>-0.20000005</Y>
                    <Z>0.5</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="43">
                <Properties>
                  <string name="Name">LeftCollarAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.9999999</X>
                    <Y>0.8000002</Y>
                    <Z>-0.00000007273974</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="44">
                <Properties>
                  <string name="Name">RightCollarAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.99999994</X>
                    <Y>0.79999995</Y>
                    <Z>0.0000000461296</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="45">
                <Properties>
                  <string name="Name">NeckAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0.8</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="46">
                <Properties>
                  <string name="Name">Waist</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>-0.00000011920929</X>
                    <Y>0.5500001</Y>
                    <Z>0.000000000000000000076446255</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.000000059604645</X>
                    <Y>-0.45000002</Y>
                    <Z>0.00000011920929</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">47</Ref>
                  <Ref name="Part1">23</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="48">
              <Properties>
                <string name="Name">LeftFoot</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-16.899857</X>
                  <Y>0.14951992</Y>
                  <Z>-11.100349</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>1</X>
                  <Y>0.3000001907348633</Y>
                  <Z>1</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220012</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>0.3000001907348633</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="49">
                <Properties>
                  <string name="Name">LeftAnkleRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.00000023841858</X>
                    <Y>0.050002575</Y>
                    <Z>0.0000008081545</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="50">
                <Properties>
                  <string name="Name">LeftAnkle</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>-0.00000017881393</X>
                    <Y>-0.7499976</Y>
                    <Z>0.00000062934055</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.00000023841858</X>
                    <Y>0.050002575</Y>
                    <Z>0.0000008081545</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">51</Ref>
                  <Ref name="Part1">48</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="51">
              <Properties>
                <string name="Name">LeftLowerLeg</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-16.899857</X>
                  <Y>0.9495201</Y>
                  <Z>-11.100349</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999999403953552</X>
                  <Y>1.5000003576278687</Y>
                  <Z>1.0000001192092896</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220017</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999999403953552</X>
                  <Y>1.5000003576278687</Y>
                  <Z>1.0000001192092896</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="52">
                <Properties>
                  <string name="Name">LeftKneeRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0.24999964</Y>
                    <Z>-0.00000017881393</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="53">
                <Properties>
                  <string name="Name">LeftAnkleRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.00000017881393</X>
                    <Y>-0.7499976</Y>
                    <Z>0.00000062934055</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="54">
                <Properties>
                  <string name="Name">LeftKnee</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0.000000059604645</X>
                    <Y>-0.29999995</Y>
                    <Z>-0.00000016391277</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0.24999964</Y>
                    <Z>-0.00000017881393</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">55</Ref>
                  <Ref name="Part1">51</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="55">
              <Properties>
                <string name="Name">LeftUpperLeg</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-16.899857</X>
                  <Y>1.4995197</Y>
                  <Z>-11.100349</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>1.0000003576278687</X>
                  <Y>1.499999761581421</Y>
                  <Z>0.9999998807907104</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220018</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>1.0000003576278687</X>
                  <Y>1.499999761581421</Y>
                  <Z>0.9999998807907104</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="56">
                <Properties>
                  <string name="Name">LeftHipRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.000000059604645</X>
                    <Y>0.5</Y>
                    <Z>-0.00000016391277</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="57">
                <Properties>
                  <string name="Name">LeftKneeRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.000000059604645</X>
                    <Y>-0.29999995</Y>
                    <Z>-0.00000016391277</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="58">
                <Properties>
                  <string name="Name">LeftHip</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>-0.5000001</X>
                    <Y>-0.19999996</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.000000059604645</X>
                    <Y>0.5</Y>
                    <Z>-0.00000016391277</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">47</Ref>
                  <Ref name="Part1">55</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="59">
              <Properties>
                <string name="Name">RightFoot</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-15.899857</X>
                  <Y>0.14951992</Y>
                  <Z>-11.1003475</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999999403953552</X>
                  <Y>0.3000001907348633</Y>
                  <Z>1</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220020</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999999403953552</X>
                  <Y>0.3000001907348633</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="60">
                <Properties>
                  <string name="Name">RightAnkleRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0.049999714</Y>
                    <Z>0.000098453434</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="61">
                <Properties>
                  <string name="Name">RightAnkle</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>-0.7500005</Y>
                    <Z>0.00009827462</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0.049999714</Y>
                    <Z>0.000098453434</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">62</Ref>
                  <Ref name="Part1">59</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="62">
              <Properties>
                <string name="Name">RightLowerLeg</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-15.899857</X>
                  <Y>0.9495201</Y>
                  <Z>-11.1003475</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>0.9999999403953552</X>
                  <Y>1.5000003576278687</Y>
                  <Z>1.0000001192092896</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220027</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>0.9999999403953552</X>
                  <Y>1.5000003576278687</Y>
                  <Z>1.0000001192092896</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="63">
                <Properties>
                  <string name="Name">RightKneeRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0.24999964</Y>
                    <Z>0.000043526004</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="64">
                <Properties>
                  <string name="Name">RightAnkleRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-0.7500005</Y>
                    <Z>0.00009827462</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="65">
                <Properties>
                  <string name="Name">RightKnee</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>-0.29999995</Y>
                    <Z>0.00004360051</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0.24999964</Y>
                    <Z>0.000043526004</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">66</Ref>
                  <Ref name="Part1">62</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="66">
              <Properties>
                <string name="Name">RightUpperLeg</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-15.899857</X>
                  <Y>1.4995197</Y>
                  <Z>-11.1003475</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>1.0000004768371582</X>
                  <Y>1.499999761581421</Y>
                  <Z>0.9999998807907104</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220031</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>1.0000004768371582</X>
                  <Y>1.499999761581421</Y>
                  <Z>0.9999998807907104</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="67">
                <Properties>
                  <string name="Name">RightHipRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0.5</Y>
                    <Z>-0.00000010430813</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="68">
                <Properties>
                  <string name="Name">RightKneeRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-0.29999995</Y>
                    <Z>0.00004360051</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="69">
                <Properties>
                  <string name="Name">RightHip</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0.49999988</X>
                    <Y>-0.19999996</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0.5</Y>
                    <Z>-0.00000010430813</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">47</Ref>
                  <Ref name="Part1">66</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="MeshPart" referent="47">
              <Properties>
                <string name="Name">LowerTorso</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-16.399857</X>
                  <Y>2.1995196</Y>
                  <Z>-11.100348</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <bool name="DoubleSided">false</bool>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <bool name="HasJointOffset">false</bool>
                <bool name="HasSkinnedMesh">false</bool>
                <Vector3 name="InitialSize">
                  <X>1.999999761581421</X>
                  <Y>0.3999999761581421</Y>
                  <Z>1.0000001192092896</Z>
                </Vector3>
                <Vector3 name="JointOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <BinaryString name="LODData">
                </BinaryString>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <Content name="MeshId">
                  <url>http://www.roblox.com/asset/?id=532220036</url>
                </Content>
                <SharedString name="PhysicalConfigData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
                <BinaryString name="PhysicsData">
                </BinaryString>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <token name="RenderFidelity">1</token>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <Vector3 name="size">
                  <X>1.999999761581421</X>
                  <Y>0.3999999761581421</Y>
                  <Z>1.0000001192092896</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <Content name="TextureID">
                  <null>
                  </null>
                </Content>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="70">
                <Properties>
                  <string name="Name">RootRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.00000011920929</X>
                    <Y>0.15000004</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="71">
                <Properties>
                  <string name="Name">WaistRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.00000011920929</X>
                    <Y>0.5500001</Y>
                    <Z>0.000000000000000000076446255</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="72">
                <Properties>
                  <string name="Name">LeftHipRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-0.5000001</X>
                    <Y>-0.19999996</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="73">
                <Properties>
                  <string name="Name">RightHipRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.49999988</X>
                    <Y>-0.19999996</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="74">
                <Properties>
                  <string name="Name">WaistCenterAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-0.2</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="75">
                <Properties>
                  <string name="Name">WaistFrontAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-0.2</Y>
                    <Z>-0.5</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="76">
                <Properties>
                  <string name="Name">WaistBackAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-0.2</Y>
                    <Z>0.5</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="77">
                <Properties>
                  <string name="Name">Root</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.00000011920929</X>
                    <Y>0.15000004</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">8</Ref>
                  <Ref name="Part1">47</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Humanoid" referent="78">
              <Properties>
                <string name="Name">Humanoid</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoJumpEnabled">true</bool>
                <bool name="AutoRotate">true</bool>
                <bool name="AutomaticScalingEnabled">true</bool>
                <bool name="BreakJointsOnDeath">true</bool>
                <token name="CollisionType">0</token>
                <token name="DisplayDistanceType">0</token>
                <string name="DisplayName"></string>
                <float name="HealthDisplayDistance">100</float>
                <token name="HealthDisplayType">0</token>
                <float name="Health_XML">100</float>
                <float name="HipHeight">1.350000023841858</float>
                <Vector3 name="InternalBodyScale">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
                <float name="InternalHeadScale">1</float>
                <float name="JumpHeight">7.199999809265137</float>
                <float name="JumpPower">50</float>
                <float name="MaxHealth">100</float>
                <float name="MaxSlopeAngle">89</float>
                <float name="NameDisplayDistance">100</float>
                <token name="NameOcclusion">2</token>
                <bool name="RequiresNeck">true</bool>
                <token name="RigType">1</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <bool name="UseJumpPower">true</bool>
                <float name="WalkSpeed">16</float>
              </Properties>
            </Item>
            <Item class="Part" referent="79">
              <Properties>
                <string name="Name">Head</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-16.399857</X>
                  <Y>4.49952</Y>
                  <Z>-11.100076</Z>
                  <R00>1</R00>
                  <R01>-0.000000000000000000000027682196</R01>
                  <R02>-0.0000016206209</R02>
                  <R10>0.000000000000000000000027682044</R10>
                  <R11>1</R11>
                  <R12>-0.00000000000000000000009388056</R12>
                  <R20>0.0000016206209</R20>
                  <R21>0.00000000000000000000009388052</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">1</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>-0.000000000000000000000000000000000000000000001401298464324817</X>
                  <Y>0</Y>
                  <Z>0.000000000000000000000000000000000000000000001401298464324817</Z>
                </Vector3>
              </Properties>
              <Item class="SpecialMesh" referent="80">
                <Properties>
                  <string name="Name">Mesh</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <token name="LODX">2</token>
                  <token name="LODY">2</token>
                  <Content name="MeshId">
                    <null>
                    </null>
                  </Content>
                  <token name="MeshType">0</token>
                  <Vector3 name="Offset">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="Scale">
                    <X>1.25</X>
                    <Y>1.25</Y>
                    <Z>1.25</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="TextureId">
                    <null>
                    </null>
                  </Content>
                  <Vector3 name="VertexColor">
                    <X>1</X>
                    <Y>1</Y>
                    <Z>1</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="Attachment" referent="81">
                <Properties>
                  <string name="Name">FaceCenterAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.000000003935688</X>
                    <Y>0</Y>
                    <Z>-0.00027224422</Z>
                    <R00>1</R00>
                    <R01>0.0000000078713756</R01>
                    <R02>0.0000000000000030299813</R02>
                    <R10>-0.0000000078713756</R10>
                    <R11>1</R11>
                    <R12>-0.00000000000000041444258</R12>
                    <R20>-0.0000000000000030299813</R20>
                    <R21>0.00000000000000041444255</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="82">
                <Properties>
                  <string name="Name">FaceFrontAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.0000000039356887</X>
                    <Y>0</Y>
                    <Z>-0.6002723</Z>
                    <R00>1</R00>
                    <R01>0.0000000078713756</R01>
                    <R02>0.0000000000000030299813</R02>
                    <R10>-0.0000000078713756</R10>
                    <R11>1</R11>
                    <R12>-0.00000000000000041444258</R12>
                    <R20>-0.0000000000000030299813</R20>
                    <R21>0.00000000000000041444255</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="83">
                <Properties>
                  <string name="Name">HairAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.000000008658514</X>
                    <Y>0.5999999</Y>
                    <Z>-0.00027224422</Z>
                    <R00>1</R00>
                    <R01>0.0000000078713756</R01>
                    <R02>0.0000000000000030299813</R02>
                    <R10>-0.0000000078713756</R10>
                    <R11>1</R11>
                    <R12>-0.00000000000000041444258</R12>
                    <R20>-0.0000000000000030299813</R20>
                    <R21>0.00000000000000041444255</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="84">
                <Properties>
                  <string name="Name">HatAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0.000000008658514</X>
                    <Y>0.5999999</Y>
                    <Z>-0.00027224422</Z>
                    <R00>1</R00>
                    <R01>0.0000000078713756</R01>
                    <R02>0.0000000000000030299813</R02>
                    <R10>-0.0000000078713756</R10>
                    <R11>1</R11>
                    <R12>-0.00000000000000041444258</R12>
                    <R20>-0.0000000000000030299813</R20>
                    <R21>0.00000000000000041444255</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="85">
                <Properties>
                  <string name="Name">NeckRigAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-0.5000001</Y>
                    <Z>-0.00027224422</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="86">
                <Properties>
                  <string name="Name">Neck</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>-0.000000059604645</X>
                    <Y>0.79999995</Y>
                    <Z>0.00000011920929</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>-0.5000001</Y>
                    <Z>-0.00027224422</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0</float>
                  <Ref name="Part0">23</Ref>
                  <Ref name="Part1">79</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Decal" referent="87">
                <Properties>
                  <string name="Name">face</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/face.png</url>
                  </Content>
                  <float name="Transparency">0</float>
                  <int name="ZIndex">1</int>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Model" referent="88">
            <Properties>
              <string name="Name">R6</string>
              <BinaryString name="AttributesSerialize">
              </BinaryString>
              <token name="LevelOfDetail">0</token>
              <CoordinateFrame name="ModelInPrimary">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <CoordinateFrame name="ModelMeshCFrame">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
                <R00>1</R00>
                <R01>0</R01>
                <R02>0</R02>
                <R10>0</R10>
                <R11>1</R11>
                <R12>0</R12>
                <R20>0</R20>
                <R21>0</R21>
                <R22>1</R22>
              </CoordinateFrame>
              <SharedString name="ModelMeshData">1B2M2Y8AsgTpgAmY7PhCfg==</SharedString>
              <Vector3 name="ModelMeshSize">
                <X>0</X>
                <Y>0</Y>
                <Z>0</Z>
              </Vector3>
              <bool name="NeedsPivotMigration">false</bool>
              <Ref name="PrimaryPart">89</Ref>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags">
              </BinaryString>
            </Properties>
            <Item class="Part" referent="90">
              <Properties>
                <string name="Name">Head</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">4</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-6.001624</X>
                  <Y>4.499999</Y>
                  <Z>24.972315</Z>
                  <R00>1</R00>
                  <R01>-0.0000000052743077</R01>
                  <R02>-0.00014418355</R02>
                  <R10>0.0000000052929336</R10>
                  <R11>1</R11>
                  <R12>0.00000012918251</R12>
                  <R20>0.00014418355</R20>
                  <R21>-0.00000012918328</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">0</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>-0.0000000000000000008316096994441546</X>
                  <Y>-0.00000000000000000023801866217211363</Y>
                  <Z>-0.00000000000000000000003851091459366696</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0.00000000000000000016122656159923196</X>
                  <Y>0.000025829816877376288</Y>
                  <Z>-0.0000000000000033909665965334247</Z>
                </Vector3>
              </Properties>
              <Item class="SpecialMesh" referent="91">
                <Properties>
                  <string name="Name">Mesh</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <token name="LODX">2</token>
                  <token name="LODY">2</token>
                  <Content name="MeshId">
                    <null>
                    </null>
                  </Content>
                  <token name="MeshType">0</token>
                  <Vector3 name="Offset">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                  </Vector3>
                  <Vector3 name="Scale">
                    <X>1.25</X>
                    <Y>1.25</Y>
                    <Z>1.25</Z>
                  </Vector3>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="TextureId">
                    <null>
                    </null>
                  </Content>
                  <Vector3 name="VertexColor">
                    <X>1</X>
                    <Y>1</Y>
                    <Z>1</Z>
                  </Vector3>
                </Properties>
              </Item>
              <Item class="Attachment" referent="92">
                <Properties>
                  <string name="Name">HatAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0.6</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="93">
                <Properties>
                  <string name="Name">HairAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0.6</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="94">
                <Properties>
                  <string name="Name">FaceFrontAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>-0.6</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="95">
                <Properties>
                  <string name="Name">FaceCenterAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Decal" referent="96">
                <Properties>
                  <string name="Name">face</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <url>rbxasset://textures/face.png</url>
                  </Content>
                  <float name="Transparency">0</float>
                  <int name="ZIndex">1</int>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="89">
              <Properties>
                <string name="Name">HumanoidRootPart</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-6.001624</X>
                  <Y>2.999999</Y>
                  <Z>24.972315</Z>
                  <R00>1</R00>
                  <R01>-0.0000000052743077</R01>
                  <R02>-0.00014418355</R02>
                  <R10>0.0000000052929336</R10>
                  <R11>1</R11>
                  <R12>0.00000012918251</R12>
                  <R20>0.00014418355</R20>
                  <R21>-0.00000012918328</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">0</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">0</float>
                <float name="LeftParamB">0</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">0</float>
                <float name="RightParamB">0</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>-0.0000000000000000008316096994441546</X>
                  <Y>-0.00000000000000000023801866217211363</Y>
                  <Z>-0.00000000000000000000003851091459366696</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">0</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">1</float>
                <Vector3 name="Velocity">
                  <X>0.00000000000000000016116880112802103</X>
                  <Y>0.000025829816877376288</Y>
                  <Z>-0.000000000000003389719128760356</Z>
                </Vector3>
              </Properties>
              <Item class="Motor6D" referent="97">
                <Properties>
                  <string name="Name">RootJoint</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>-1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>0</R11>
                    <R12>1</R12>
                    <R20>0</R20>
                    <R21>1</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0</Z>
                    <R00>-1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>0</R11>
                    <R12>1</R12>
                    <R20>0</R20>
                    <R21>1</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0.10000000149011612</float>
                  <Ref name="Part0">89</Ref>
                  <Ref name="Part1">98</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="99">
              <Properties>
                <string name="Name">Left Arm</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">4</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-7.501624</X>
                  <Y>2.999999</Y>
                  <Z>24.9721</Z>
                  <R00>1</R00>
                  <R01>-0.0000000052743077</R01>
                  <R02>-0.00014418355</R02>
                  <R10>0.0000000052929336</R10>
                  <R11>1</R11>
                  <R12>0.00000012918251</R12>
                  <R20>0.00014418355</R20>
                  <R21>-0.00000012918328</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">0</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>-0.0000000000000000008316096994441546</X>
                  <Y>-0.00000000000000000023801866217211363</Y>
                  <Z>-0.00000000000000000000003851091459366696</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">3</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0.0000000000000000001612200992506964</X>
                  <Y>0.000025829816877376288</Y>
                  <Z>-0.0000000000000033900761531476236</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="100">
                <Properties>
                  <string name="Name">LeftShoulderAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>1</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="101">
              <Properties>
                <string name="Name">Left Leg</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-6.501624</X>
                  <Y>0.99999905</Y>
                  <Z>24.972242</Z>
                  <R00>1</R00>
                  <R01>-0.0000000052743077</R01>
                  <R02>-0.00014418355</R02>
                  <R10>0.0000000052929336</R10>
                  <R11>1</R11>
                  <R12>0.00000012918251</R12>
                  <R20>0.00014418355</R20>
                  <R21>-0.00000012918328</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">0</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>-0.0000000000000000008316096994441546</X>
                  <Y>-0.00000000000000000023801866217211363</Y>
                  <Z>-0.00000000000000000000003851091459366696</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">3</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0.000000000000000000161109024404067</X>
                  <Y>0.000025829816877376288</Y>
                  <Z>-0.0000000000000033881749876975113</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="102">
              <Properties>
                <string name="Name">Right Arm</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">4</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-4.501624</X>
                  <Y>2.999999</Y>
                  <Z>24.97253</Z>
                  <R00>1</R00>
                  <R01>-0.0000000052743077</R01>
                  <R02>-0.00014418355</R02>
                  <R10>0.0000000052929336</R10>
                  <R11>1</R11>
                  <R12>0.00000012918251</R12>
                  <R20>0.00014418355</R20>
                  <R21>-0.00000012918328</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">0</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>-0.0000000000000000008316096994441546</X>
                  <Y>-0.00000000000000000023801866217211363</Y>
                  <Z>-0.00000000000000000000003851091459366696</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">3</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0.00000000000000000016111750300534568</X>
                  <Y>0.000025829816877376288</Y>
                  <Z>-0.0000000000000033893621043730882</Z>
                </Vector3>
              </Properties>
              <Item class="Attachment" referent="103">
                <Properties>
                  <string name="Name">RightShoulderAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>1</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
            </Item>
            <Item class="Part" referent="104">
              <Properties>
                <string name="Name">Right Leg</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">0</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-5.501624</X>
                  <Y>0.99999905</Y>
                  <Z>24.972387</Z>
                  <R00>1</R00>
                  <R01>-0.0000000052743077</R01>
                  <R02>-0.00014418355</R02>
                  <R10>0.0000000052929336</R10>
                  <R11>1</R11>
                  <R12>0.00000012918251</R12>
                  <R20>0.00014418355</R20>
                  <R21>-0.00000012918328</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">false</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">0</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">-0.5</float>
                <float name="LeftParamB">0.5</float>
                <token name="LeftSurface">0</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">-0.5</float>
                <float name="RightParamB">0.5</float>
                <token name="RightSurface">0</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>-0.0000000000000000008316096994441546</X>
                  <Y>-0.00000000000000000023801866217211363</Y>
                  <Z>-0.00000000000000000000003851091459366696</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>1</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">3</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0.00000000000000000016107452838758413</X>
                  <Y>0.000025829816877376288</Y>
                  <Z>-0.000000000000003387936971439333</Z>
                </Vector3>
              </Properties>
            </Item>
            <Item class="Part" referent="98">
              <Properties>
                <string name="Name">Torso</string>
                <bool name="Anchored">false</bool>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <float name="BackParamA">-0.5</float>
                <float name="BackParamB">0.5</float>
                <token name="BackSurface">0</token>
                <token name="BackSurfaceInput">0</token>
                <float name="BottomParamA">-0.5</float>
                <float name="BottomParamB">0.5</float>
                <token name="BottomSurface">4</token>
                <token name="BottomSurfaceInput">0</token>
                <CoordinateFrame name="CFrame">
                  <X>-6.001624</X>
                  <Y>2.999999</Y>
                  <Z>24.972315</Z>
                  <R00>1</R00>
                  <R01>-0.0000000052743077</R01>
                  <R02>-0.00014418355</R02>
                  <R10>0.0000000052929336</R10>
                  <R11>1</R11>
                  <R12>0.00000012918251</R12>
                  <R20>0.00014418355</R20>
                  <R21>-0.00000012918328</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <bool name="CanCollide">true</bool>
                <bool name="CanQuery">true</bool>
                <bool name="CanTouch">true</bool>
                <bool name="CastShadow">true</bool>
                <int name="CollisionGroupId">0</int>
                <Color3uint8 name="Color3uint8">10724005</Color3uint8>
                <PhysicalProperties name="CustomPhysicalProperties">
                  <CustomPhysics>false</CustomPhysics>
                </PhysicalProperties>
                <token name="formFactorRaw">0</token>
                <float name="FrontParamA">-0.5</float>
                <float name="FrontParamB">0.5</float>
                <token name="FrontSurface">0</token>
                <token name="FrontSurfaceInput">0</token>
                <float name="LeftParamA">0</float>
                <float name="LeftParamB">0</float>
                <token name="LeftSurface">2</token>
                <token name="LeftSurfaceInput">0</token>
                <bool name="Locked">false</bool>
                <bool name="Massless">false</bool>
                <token name="Material">256</token>
                <CoordinateFrame name="PivotOffset">
                  <X>0</X>
                  <Y>0</Y>
                  <Z>0</Z>
                  <R00>1</R00>
                  <R01>0</R01>
                  <R02>0</R02>
                  <R10>0</R10>
                  <R11>1</R11>
                  <R12>0</R12>
                  <R20>0</R20>
                  <R21>0</R21>
                  <R22>1</R22>
                </CoordinateFrame>
                <float name="Reflectance">0</float>
                <float name="RightParamA">0</float>
                <float name="RightParamB">0</float>
                <token name="RightSurface">2</token>
                <token name="RightSurfaceInput">0</token>
                <int name="RootPriority">0</int>
                <Vector3 name="RotVelocity">
                  <X>-0.0000000000000000008316096994441546</X>
                  <Y>-0.00000000000000000023801866217211363</Y>
                  <Z>-0.00000000000000000000003851091459366696</Z>
                </Vector3>
                <token name="shape">1</token>
                <Vector3 name="size">
                  <X>2</X>
                  <Y>2</Y>
                  <Z>1</Z>
                </Vector3>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <float name="TopParamA">-0.5</float>
                <float name="TopParamB">0.5</float>
                <token name="TopSurface">3</token>
                <token name="TopSurfaceInput">0</token>
                <float name="Transparency">0</float>
                <Vector3 name="Velocity">
                  <X>0.00000000000000000016116880112802103</X>
                  <Y>0.000025829816877376288</Y>
                  <Z>-0.000000000000003389719128760356</Z>
                </Vector3>
              </Properties>
              <Item class="Decal" referent="105">
                <Properties>
                  <string name="Name">roblox</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <Color3 name="Color3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <token name="Face">5</token>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <Content name="Texture">
                    <null>
                    </null>
                  </Content>
                  <float name="Transparency">0</float>
                  <int name="ZIndex">1</int>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="106">
                <Properties>
                  <string name="Name">Right Shoulder</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>1</X>
                    <Y>0.5</Y>
                    <Z>0</Z>
                    <R00>0</R00>
                    <R01>0</R01>
                    <R02>1</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>-1</R20>
                    <R21>0</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.5</X>
                    <Y>0.5</Y>
                    <Z>0</Z>
                    <R00>0</R00>
                    <R01>0</R01>
                    <R02>1</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>-1</R20>
                    <R21>0</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0.10000000149011612</float>
                  <Ref name="Part0">98</Ref>
                  <Ref name="Part1">102</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="107">
                <Properties>
                  <string name="Name">Right Hip</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>1</X>
                    <Y>-1</Y>
                    <Z>0</Z>
                    <R00>0</R00>
                    <R01>0</R01>
                    <R02>1</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>-1</R20>
                    <R21>0</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.5</X>
                    <Y>1</Y>
                    <Z>0</Z>
                    <R00>0</R00>
                    <R01>0</R01>
                    <R02>1</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>-1</R20>
                    <R21>0</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0.10000000149011612</float>
                  <Ref name="Part0">98</Ref>
                  <Ref name="Part1">104</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="108">
                <Properties>
                  <string name="Name">Neck</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>0</X>
                    <Y>1</Y>
                    <Z>0</Z>
                    <R00>-1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>0</R11>
                    <R12>1</R12>
                    <R20>0</R20>
                    <R21>1</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0</X>
                    <Y>-0.5</Y>
                    <Z>0</Z>
                    <R00>-1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>0</R11>
                    <R12>1</R12>
                    <R20>0</R20>
                    <R21>1</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0.10000000149011612</float>
                  <Ref name="Part0">98</Ref>
                  <Ref name="Part1">90</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="109">
                <Properties>
                  <string name="Name">Left Shoulder</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>-1</X>
                    <Y>0.5</Y>
                    <Z>0</Z>
                    <R00>0</R00>
                    <R01>0</R01>
                    <R02>-1</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>1</R20>
                    <R21>0</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>0.5</X>
                    <Y>0.5</Y>
                    <Z>0</Z>
                    <R00>0</R00>
                    <R01>0</R01>
                    <R02>-1</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>1</R20>
                    <R21>0</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0.10000000149011612</float>
                  <Ref name="Part0">98</Ref>
                  <Ref name="Part1">99</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Motor6D" referent="110">
                <Properties>
                  <string name="Name">Left Hip</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="C0">
                    <X>-1</X>
                    <Y>-1</Y>
                    <Z>0</Z>
                    <R00>0</R00>
                    <R01>0</R01>
                    <R02>-1</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>1</R20>
                    <R21>0</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <CoordinateFrame name="C1">
                    <X>-0.5</X>
                    <Y>1</Y>
                    <Z>0</Z>
                    <R00>0</R00>
                    <R01>0</R01>
                    <R02>-1</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>1</R20>
                    <R21>0</R21>
                    <R22>0</R22>
                  </CoordinateFrame>
                  <float name="DesiredAngle">0</float>
                  <bool name="Enabled">true</bool>
                  <float name="MaxVelocity">0.10000000149011612</float>
                  <Ref name="Part0">98</Ref>
                  <Ref name="Part1">101</Ref>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                </Properties>
              </Item>
              <Item class="Attachment" referent="111">
                <Properties>
                  <string name="Name">WaistFrontAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-1</Y>
                    <Z>-0.5</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="112">
                <Properties>
                  <string name="Name">WaistCenterAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-1</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="113">
                <Properties>
                  <string name="Name">WaistBackAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>-1</Y>
                    <Z>0.5</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="114">
                <Properties>
                  <string name="Name">RightCollarAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>1</X>
                    <Y>1</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="115">
                <Properties>
                  <string name="Name">NeckAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>1</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="116">
                <Properties>
                  <string name="Name">LeftCollarAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>-1</X>
                    <Y>1</Y>
                    <Z>0</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="117">
                <Properties>
                  <string name="Name">BodyFrontAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>-0.5</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
              <Item class="Attachment" referent="118">
                <Properties>
                  <string name="Name">BodyBackAttachment</string>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <CoordinateFrame name="CFrame">
                    <X>0</X>
                    <Y>0</Y>
                    <Z>0.5</Z>
                    <R00>1</R00>
                    <R01>0</R01>
                    <R02>0</R02>
                    <R10>0</R10>
                    <R11>1</R11>
                    <R12>0</R12>
                    <R20>0</R20>
                    <R21>0</R21>
                    <R22>1</R22>
                  </CoordinateFrame>
                  <int64 name="SourceAssetId">-1</int64>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">false</bool>
                </Properties>
              </Item>
            </Item>
            <Item class="Humanoid" referent="119">
              <Properties>
                <string name="Name">Humanoid</string>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoJumpEnabled">true</bool>
                <bool name="AutoRotate">true</bool>
                <bool name="AutomaticScalingEnabled">true</bool>
                <bool name="BreakJointsOnDeath">true</bool>
                <token name="CollisionType">0</token>
                <token name="DisplayDistanceType">0</token>
                <string name="DisplayName"></string>
                <float name="HealthDisplayDistance">100</float>
                <token name="HealthDisplayType">0</token>
                <float name="Health_XML">100</float>
                <float name="HipHeight">0</float>
                <Vector3 name="InternalBodyScale">
                  <X>1</X>
                  <Y>1</Y>
                  <Z>1</Z>
                </Vector3>
                <float name="InternalHeadScale">1</float>
                <float name="JumpHeight">7.199999809265137</float>
                <float name="JumpPower">50</float>
                <float name="MaxHealth">100</float>
                <float name="MaxSlopeAngle">89</float>
                <float name="NameDisplayDistance">100</float>
                <token name="NameOcclusion">2</token>
                <bool name="RequiresNeck">true</bool>
                <token name="RigType">0</token>
                <int64 name="SourceAssetId">-1</int64>
                <BinaryString name="Tags">
                </BinaryString>
                <bool name="UseJumpPower">true</bool>
                <float name="WalkSpeed">16</float>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="120">
        <Properties>
          <string name="Name">faction_manager</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local GroupService = _services.GroupService
local Players = _services.Players
local RunService = _services.RunService
local _faction = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "faction_manager", "faction")
local ClientFaction = _faction.ClientFaction
local Faction = _faction.Faction
local FactionRemotes = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "faction_manager", "faction_remotes").default
local cleanGroupName = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "faction_manager", "utility_functions").cleanGroupName
local clientInfo = RunService:IsServer() and {} or nil
local cachingConnections
local factions
local groupId = 4978642
--[[
	*
	* Cannot be called from the client.
	* Gets a list of allied factions.
]]
local function getFactions(update)
	if RunService:IsClient() or not clientInfo then
		error("Cannot be called from the client")
	end
	if update or not factions then
		local newAllies = {}
		local allyPages = GroupService:GetAlliesAsync(groupId)
		while true do
			local _exp = allyPages:GetCurrentPage()
			local _arg0 = function(group)
				group.Name = cleanGroupName(group.Name)
				-- ▼ Array.push ▼
				newAllies[#newAllies + 1] = group
				-- ▲ Array.push ▲
			end
			-- ▼ ReadonlyArray.forEach ▼
			for _k, _v in ipairs(_exp) do
				_arg0(_v, _k - 1, _exp)
			end
			-- ▲ ReadonlyArray.forEach ▲
			if allyPages.IsFinished then
				break
			else
				allyPages:AdvanceToNextPageAsync()
			end
		end
		factions = {}
		local _arg0 = function(group)
			local _factions = factions
			local _id = group.Id
			local _faction_1 = Faction.new(group)
			-- ▼ Map.set ▼
			_factions[_id] = _faction_1
			-- ▲ Map.set ▲
			return _factions
		end
		-- ▼ ReadonlyArray.forEach ▼
		for _k, _v in ipairs(newAllies) do
			_arg0(_v, _k - 1, newAllies)
		end
		-- ▲ ReadonlyArray.forEach ▲
	end
	return factions
end
--[[
	*
	* Used for caching player group information on the server.
	* **ONLY ACCESSIBLE FROM THE SERVER**
]]
local quitCaching
local function startCaching()
	if RunService:IsClient() or not clientInfo then
		error("Cannot be called from the client")
	end
	quitCaching()
	cachingConnections = {}
	local factionRemote = FactionRemotes.Server:Create("GetClientInfo")
	local factions = getFactions(true)
	local _cachingConnections = cachingConnections
	local _arg0 = Players.PlayerAdded:Connect(function(player)
		local _arg0_1 = function(faction)
			local _roles = faction.roles
			local _arg0_2 = player:GetRankInGroup(faction.groupId)
			local role = _roles[_arg0_2]
			if role then
				-- ▼ Map.set ▼
				faction.players[player] = role
				-- ▲ Map.set ▲
			end
		end
		-- ▼ ReadonlyMap.forEach ▼
		for _k, _v in pairs(factions) do
			_arg0_1(_v, _k, factions)
		end
		-- ▲ ReadonlyMap.forEach ▲
		return nil
	end)
	-- ▼ Array.push ▼
	_cachingConnections[#_cachingConnections + 1] = _arg0
	-- ▲ Array.push ▲
	local onPlayer = function(player)
		local _arg0_1 = function(faction)
			local rank = player:GetRankInGroup(faction.groupId)
			local role = faction.roles[rank]
			if role then
				-- ▼ Map.set ▼
				faction.players[player] = role
				-- ▲ Map.set ▲
				if not clientInfo[player] then
					-- ▼ Map.set ▼
					clientInfo[player] = {
						factions = {},
					}
					-- ▲ Map.set ▲
				end
				local roles = {}
				local _roles = faction.roles
				local _arg0_2 = function(role)
					local _arg0_3 = {
						name = role.name,
						id = role.id,
						faction = faction.groupId,
					}
					-- ▼ Array.push ▼
					local _length = #roles
					roles[_length + 1] = _arg0_3
					-- ▲ Array.push ▲
					return _length + 1
				end
				-- ▼ ReadonlyMap.forEach ▼
				for _k, _v in pairs(_roles) do
					_arg0_2(_v, _k, _roles)
				end
				-- ▲ ReadonlyMap.forEach ▲
				local _result = clientInfo[player]
				if _result ~= nil then
					local _factions = _result.factions
					local _arg0_3 = {
						name = faction.name,
						shortName = faction.shortName,
						groupId = faction.groupId,
						roles = roles,
						color = faction.color,
						clientRole = rank,
					}
					-- ▼ Array.push ▼
					_factions[#_factions + 1] = _arg0_3
					-- ▲ Array.push ▲
				end
			end
		end
		-- ▼ ReadonlyMap.forEach ▼
		for _k, _v in pairs(factions) do
			_arg0_1(_v, _k, factions)
		end
		-- ▲ ReadonlyMap.forEach ▲
		return nil
	end
	Players.PlayerAdded:Connect(onPlayer)
	local _exp = Players:GetPlayers()
	-- ▼ ReadonlyArray.forEach ▼
	for _k, _v in ipairs(_exp) do
		onPlayer(_v, _k - 1, _exp)
	end
	-- ▲ ReadonlyArray.forEach ▲
	factionRemote:SetCallback(function(player)
		local _condition = clientInfo[player]
		if _condition == nil then
			_condition = error("Client info for player " .. tostring(player) .. " does not exist")
		end
		return _condition
	end)
end
function quitCaching()
	if cachingConnections then
		local _cachingConnections = cachingConnections
		local _arg0 = function(connection)
			return connection:Disconnect()
		end
		-- ▼ ReadonlyArray.forEach ▼
		for _k, _v in ipairs(_cachingConnections) do
			_arg0(_v, _k - 1, _cachingConnections)
		end
		-- ▲ ReadonlyArray.forEach ▲
	end
end
local clientFactionInfo
local getClientFactionInfo = TS.async(function(update)
	if update or not clientFactionInfo then
		local clientData = FactionRemotes.Client:WaitFor("GetClientInfo"):andThen(function(remote)
			return remote:CallServerAsync()
		end)
		local _factions = (TS.await(clientData)).factions
		local _arg0 = function(factionInfo)
			return ClientFaction.new(factionInfo)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_factions)
		for _k, _v in ipairs(_factions) do
			_newValue[_k] = _arg0(_v, _k - 1, _factions)
		end
		-- ▲ ReadonlyArray.map ▲
		clientFactionInfo = _newValue
	end
	return clientFactionInfo
end)
return {
	getFactions = getFactions,
	startCaching = startCaching,
	quitCaching = quitCaching,
	getClientFactionInfo = getClientFactionInfo,
}
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="121">
          <Properties>
            <string name="Name">faction</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local _utility_functions = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "faction_manager", "utility_functions")
local assignColor = _utility_functions.assignColor
local generateShortName = _utility_functions.generateShortName
--[[
	*
	* Stores information on factions and provides speedy alternatives to existing player/groupservice methods
]]
local Role
do
	Role = setmetatable({}, {
		__tostring = function()
			return "Role"
		end,
	})
	Role.__index = Role
	function Role.new(...)
		local self = setmetatable({}, Role)
		return self:constructor(...) or self
	end
	function Role:constructor(roleInfo, faction)
		self.faction = faction
		self.name = roleInfo.Name
		self.id = roleInfo.Rank
	end
	function Role:hasRole(player)
		return self.faction:getRole(player) == self
	end
end
--[[
	*
	* Stores information on factions and provides speedy alternatives to existing player/groupservice methods
]]
local Faction
do
	Faction = setmetatable({}, {
		__tostring = function()
			return "Faction"
		end,
	})
	Faction.__index = Faction
	function Faction.new(...)
		local self = setmetatable({}, Faction)
		return self:constructor(...) or self
	end
	function Faction:constructor(groupInfo)
		self.groupInfo = groupInfo
		self.players = {}
		self.roles = {}
		self.name = groupInfo.Name
		self.groupId = groupInfo.Id
		local _roles = groupInfo.Roles
		local _arg0 = function(roleInfo)
			return Role.new(roleInfo, self)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_roles)
		for _k, _v in ipairs(_roles) do
			_newValue[_k] = _arg0(_v, _k - 1, _roles)
		end
		-- ▲ ReadonlyArray.map ▲
		local _arg0_1 = function(role)
			local _roles_1 = self.roles
			local _id = role.id
			-- ▼ Map.set ▼
			_roles_1[_id] = role
			-- ▲ Map.set ▲
			return _roles_1
		end
		-- ▼ ReadonlyArray.forEach ▼
		for _k, _v in ipairs(_newValue) do
			_arg0_1(_v, _k - 1, _newValue)
		end
		-- ▲ ReadonlyArray.forEach ▲
		self.color = assignColor(tostring((string.match(groupInfo.Description, [=[Color:%s*["']([%w ]*)["']]=]))))
		local _condition = (string.match(groupInfo.Description, [=[ShortName:%s*["']([%a ]*)["']]=]))
		if _condition == nil then
			_condition = self.name
		end
		self.shortName = generateShortName(tostring(_condition))
		self.uniformTop = tonumber((string.match(groupInfo.Description, [[UniformTop:%s*["']([%d]*)["']] .. "]")))
		self.uniformBottom = tonumber((string.match(groupInfo.Description, [=[UniformBottom:%s*["']([%d]*)["']]=])))
		Players.PlayerAdded:Connect(function(player)
			return self:onPlayer(player)
		end)
		local _exp = Players:GetPlayers()
		local _arg0_2 = function(player)
			return self:onPlayer(player)
		end
		-- ▼ ReadonlyArray.forEach ▼
		for _k, _v in ipairs(_exp) do
			_arg0_2(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.forEach ▲
	end
	function Faction:onPlayer(player)
		local rank = self:getRoleUncached(player)
		if rank then
			-- ▼ Map.set ▼
			self.players[player] = rank
			-- ▲ Map.set ▲
		end
	end
	function Faction:getRoleUncached(player)
		local _roles = self.roles
		local _arg0 = player:GetRankInGroup(self.groupId)
		return _roles[_arg0]
	end
	function Faction:isInFaction(player)
		return self.players[player] ~= nil
	end
	function Faction:getRole(player)
		return self.players[player]
	end
end
local ClientRole
do
	ClientRole = setmetatable({}, {
		__tostring = function()
			return "ClientRole"
		end,
	})
	ClientRole.__index = ClientRole
	function ClientRole.new(...)
		local self = setmetatable({}, ClientRole)
		return self:constructor(...) or self
	end
	function ClientRole:constructor(roleInfo, faction)
		self.name = roleInfo.name
		self.id = roleInfo.id
		self.faction = faction
	end
	function ClientRole:hasRole()
		return self.faction.clientRole == self
	end
end
local ClientFaction
do
	ClientFaction = setmetatable({}, {
		__tostring = function()
			return "ClientFaction"
		end,
	})
	ClientFaction.__index = ClientFaction
	function ClientFaction.new(...)
		local self = setmetatable({}, ClientFaction)
		return self:constructor(...) or self
	end
	function ClientFaction:constructor(factionInfo)
		self.name = factionInfo.name
		self.shortName = factionInfo.shortName
		self.groupId = factionInfo.groupId
		local _roles = factionInfo.roles
		local _arg0 = function(roleInfo)
			return ClientRole.new(roleInfo, self)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_roles)
		for _k, _v in ipairs(_roles) do
			_newValue[_k] = _arg0(_v, _k - 1, _roles)
		end
		-- ▲ ReadonlyArray.map ▲
		self.roles = _newValue
		self.color = factionInfo.color
		local _roles_1 = self.roles
		local _arg0_1 = function(role)
			return factionInfo.clientRole == role.id
		end
		-- ▼ ReadonlyArray.find ▼
		local _result = nil
		for _i, _v in ipairs(_roles_1) do
			if _arg0_1(_v, _i - 1, _roles_1) == true then
				_result = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		self.clientRole = _result
		self.uniformTop = factionInfo.uniformTop
		self.uniformBottom = factionInfo.uniformBottom
	end
	function ClientFaction:getRole()
		return self.clientRole
	end
end
return {
	Role = Role,
	Faction = Faction,
	ClientFaction = ClientFaction,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="122">
          <Properties>
            <string name="Name">faction_data_interfaces</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
return nil
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="123">
          <Properties>
            <string name="Name">faction_remotes</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Net = TS.import(script, TS.getModule(script, "@rbxts", "net").out)
local FactionRemotes = Net.Definitions.Create({
	GetClientInfo = Net.Definitions.ServerFunction(),
})
local default = FactionRemotes
return {
	default = default,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="124">
          <Properties>
            <string name="Name">utility_functions</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
-- const usedColors = new Array<number>();
--[[
	* returns a random color
	* NOT IMPLEMENTED
]]
local function assignColor(color)
	return BrickColor.new(1)
end
-- * extracts the first letter of every word in a string
local function generateShortName(name)
	local words = string.split(name, " ")
	local _arg0 = function(word)
		local _condition = (string.match(word, "%a"))
		if _condition == nil then
			_condition = ""
		end
		return _condition
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#words)
	for _k, _v in ipairs(words) do
		_newValue[_k] = _arg0(_v, _k - 1, words)
	end
	-- ▲ ReadonlyArray.map ▲
	-- ▼ ReadonlyArray.join ▼
	local _arg0_1 = ""
	if _arg0_1 == nil then
		_arg0_1 = ", "
	end
	-- ▲ ReadonlyArray.join ▲
	local shortName = table.concat(_newValue, _arg0_1)
	return shortName
end
-- * removes any non-alphanumeric characters from a string
local function cleanGroupName(name)
	local outArray = {}
	local i = 1
	local _i = i
	local _i_1 = i
	local char = string.sub(name, _i, _i_1)
	while char ~= "" do
		local _value = char == " " or (string.match(char, "%a"))
		if _value ~= 0 and _value == _value and _value ~= "" and _value then
			local _char = char
			-- ▼ Array.push ▼
			outArray[#outArray + 1] = _char
			-- ▲ Array.push ▲
		end
		i += 1
		local _i_2 = i
		local _i_3 = i
		char = string.sub(name, _i_2, _i_3)
	end
	-- ▼ ReadonlyArray.join ▼
	local _arg0 = ""
	if _arg0 == nil then
		_arg0 = ", "
	end
	-- ▲ ReadonlyArray.join ▲
	local outStr = table.concat(outArray, _arg0)
	local _condition = (string.match(outStr, "^%s*(%a+[%a%s]*%a+)%s*$"))
	if _condition == nil then
		_condition = (string.match(outStr, "^%s*(%a+)%s*$"))
		if _condition == nil then
			_condition = "Invalid Group Name!"
		end
	end
	return _condition
end
return {
	assignColor = assignColor,
	generateShortName = generateShortName,
	cleanGroupName = cleanGroupName,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="125">
        <Properties>
          <string name="Name">map</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Point = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "map", "point").Point
-- * used for holding all points in a game- generally for spawn locations
local GameMap
do
	GameMap = setmetatable({}, {
		__tostring = function()
			return "GameMap"
		end,
	})
	GameMap.__index = GameMap
	function GameMap.new(...)
		local self = setmetatable({}, GameMap)
		return self:constructor(...) or self
	end
	function GameMap:constructor(points, bounds)
		self.points = points
		self.bounds = bounds
		local _exp = bounds[2]
		local _arg0 = bounds[1]
		self.size = _exp - _arg0
		local _arg0_1 = function(absPoint)
			local _position = absPoint.position
			local _arg0_2 = bounds[1]
			return Point.new(_position - _arg0_2, absPoint.name, absPoint.canSpawn, absPoint.safezone)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#points)
		for _k, _v in ipairs(points) do
			_newValue[_k] = _arg0_1(_v, _k - 1, points)
		end
		-- ▲ ReadonlyArray.map ▲
		self.points = _newValue
	end
end
return {
	GameMap = GameMap,
}
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="126">
          <Properties>
            <string name="Name">point</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
-- * a 2d point in the game- generally used for spawn locations
local Point
do
	Point = setmetatable({}, {
		__tostring = function()
			return "Point"
		end,
	})
	Point.__index = Point
	function Point.new(...)
		local self = setmetatable({}, Point)
		return self:constructor(...) or self
	end
	function Point:constructor(position, name, canSpawn, safezone)
		self.position = position
		self.name = name
		self.canSpawn = canSpawn
		self.safezone = safezone
	end
end
return {
	Point = Point,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="127">
          <Properties>
            <string name="Name">point_gen</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local Point = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "map", "point").Point
local isValidPointConstructor = t.children({
	PointName = t.instanceIsA("StringValue"),
	Position = t.children({
		X = t.instanceIsA("NumberValue"),
		Y = t.instanceIsA("NumberValue"),
	}),
	CanSpawn = t.instanceIsA("BoolValue"),
	Safezone = t.instanceIsA("BoolValue"),
})
local getValidPointConstructors = function(pointConstructors)
	local _arg0 = function(pointConstructor)
		return isValidPointConstructor(pointConstructor) and pointConstructor or nil
	end
	-- ▼ ReadonlyArray.mapFiltered ▼
	local _newValue = {}
	local _length = 0
	for _k, _v in ipairs(pointConstructors) do
		local _result = _arg0(_v, _k - 1, pointConstructors)
		if _result ~= nil then
			_length += 1
			_newValue[_length] = _result
		end
	end
	-- ▲ ReadonlyArray.mapFiltered ▲
	return _newValue
end
-- * generates an array of `Point` objects from an array of valid `PointConstructor` instances (see PointConsturctor type)
local function genPoints(pointConstructors)
	local _exp = getValidPointConstructors(pointConstructors)
	local _arg0 = function(pointConstructor)
		return Point.new(Vector2.new(pointConstructor.Position.X.Value, pointConstructor.Position.X.Value), pointConstructor.PointName.Value, pointConstructor.CanSpawn.Value, pointConstructor.Safezone.Value)
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#_exp)
	for _k, _v in ipairs(_exp) do
		_newValue[_k] = _arg0(_v, _k - 1, _exp)
	end
	-- ▲ ReadonlyArray.map ▲
	return _newValue
end
-- * determines the bounds of a map from an array of `Point` objects and returns a tuple of the upper and lower bounds
local function mapBounds(points)
	local _arg0 = function(lowest, current)
		return current.position.X < lowest.position.X and current or lowest
	end
	-- ▼ ReadonlyArray.reduce ▼
	if #points == 0 then
		error("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.")
	end
	local _result = points[1]
	local _callback = _arg0
	for _i = 2, #points do
		_result = _callback(_result, points[_i], _i - 1, points)
	end
	-- ▲ ReadonlyArray.reduce ▲
	local _exp = _result.position.X
	local _arg0_1 = function(lowest, current)
		return current.position.Y < lowest.position.Y and current or lowest
	end
	-- ▼ ReadonlyArray.reduce ▼
	if #points == 0 then
		error("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.")
	end
	local _result_1 = points[1]
	local _callback_1 = _arg0_1
	for _i = 2, #points do
		_result_1 = _callback_1(_result_1, points[_i], _i - 1, points)
	end
	-- ▲ ReadonlyArray.reduce ▲
	local _exp_1 = Vector2.new(_exp, _result_1.position.Y)
	local _arg0_2 = function(highest, current)
		return current.position.X > highest.position.X and current or highest
	end
	-- ▼ ReadonlyArray.reduce ▼
	if #points == 0 then
		error("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.")
	end
	local _result_2 = points[1]
	local _callback_2 = _arg0_2
	for _i = 2, #points do
		_result_2 = _callback_2(_result_2, points[_i], _i - 1, points)
	end
	-- ▲ ReadonlyArray.reduce ▲
	local _exp_2 = _result_2.position.X
	local _arg0_3 = function(highest, current)
		return current.position.Y > highest.position.Y and current or highest
	end
	-- ▼ ReadonlyArray.reduce ▼
	if #points == 0 then
		error("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.")
	end
	local _result_3 = points[1]
	local _callback_3 = _arg0_3
	for _i = 2, #points do
		_result_3 = _callback_3(_result_3, points[_i], _i - 1, points)
	end
	-- ▲ ReadonlyArray.reduce ▲
	return { _exp_1, Vector2.new(_exp_2, _result_3.position.Y) }
end
return {
	genPoints = genPoints,
	mapBounds = mapBounds,
}
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="128">
        <Properties>
          <string name="Name">region</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local RotatedRegion3 = TS.import(script, TS.getModule(script, "@rbxts", "rotatedregion3"))
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local RunService = _services.RunService
local Workspace = _services.Workspace
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local Region
do
	Region = {}
	function Region:constructor()
	end
end
--[[
	*
	* Rectangular regions are a great way to define event-based areas using Roblox's own physics engine
]]
local BasePartRegion
do
	local super = Region
	BasePartRegion = setmetatable({}, {
		__tostring = function()
			return "BasePartRegion"
		end,
		__index = super,
	})
	BasePartRegion.__index = BasePartRegion
	function BasePartRegion.new(...)
		local self = setmetatable({}, BasePartRegion)
		return self:constructor(...) or self
	end
	function BasePartRegion:constructor(part)
		super.constructor(self)
		local newPart = Instance.new("Part")
		newPart.CFrame = part.CFrame
		newPart.Size = part.Size
		newPart.Shape = t.instanceIsA("Part")(part) and part.Shape or Enum.PartType.Block
		newPart.Anchored = true
		newPart.Transparency = 1
		newPart.CanCollide = false
		newPart.CanTouch = true
		newPart.Parent = RunService:IsClient() and Workspace or nil
		newPart.Name = tostring(self)
		self.part = newPart
		self.rotatedRegion3 = RotatedRegion3.FromPart(self.part)
	end
	BasePartRegion.enteredRegion = TS.async(function(self, part)
		if RunService:IsClient() then
			local inRegion = self:isInRegion(part)
			while not inRegion do
				inRegion = (part.Touched:Wait()) == self.part
			end
		else
			while self:isInRegion(part) do
				wait(0.1)
			end
		end
	end)
	BasePartRegion.leftRegion = TS.async(function(self, part)
		if RunService:IsClient() then
			local inRegion = self:isInRegion(part)
			while inRegion do
				inRegion = not ((part.TouchEnded:Wait()) == self.part)
			end
		else
			while self:isInRegion(part) do
				wait(0.1)
			end
		end
	end)
	function BasePartRegion:isInRegion(part)
		return self.rotatedRegion3:CastPoint(part.Position)
	end
end
--[[
	*
	* Spherical regions offer a much faster alternative to rectangular regions, as simple distance checks are much faster
]]
local SphereRegion
do
	local super = Region
	SphereRegion = setmetatable({}, {
		__tostring = function()
			return "SphereRegion"
		end,
		__index = super,
	})
	SphereRegion.__index = SphereRegion
	function SphereRegion.new(...)
		local self = setmetatable({}, SphereRegion)
		return self:constructor(...) or self
	end
	function SphereRegion:constructor(sphere)
		super.constructor(self)
		self.center = sphere.Position
		self.radius = math.min(sphere.Size.X, sphere.Size.Y, sphere.Size.Z)
	end
	SphereRegion.enteredRegion = TS.async(function(self, part)
		while not self:isInRegion(part) do
			wait(0.1)
		end
	end)
	SphereRegion.leftRegion = TS.async(function(self, part)
		while self:isInRegion(part) do
			wait(0.1)
		end
	end)
	function SphereRegion:isInRegion(part)
		local _position = part.Position
		local _center = self.center
		return (_position - _center).Magnitude <= self.radius
	end
	function SphereRegion:getDistance(part)
		local _position = part.Position
		local _center = self.center
		return (_position - _center).Magnitude
	end
end
--[[
	*
	* A handy way to group regions of any type
]]
local RegionUnion
do
	RegionUnion = setmetatable({}, {
		__tostring = function()
			return "RegionUnion"
		end,
	})
	RegionUnion.__index = RegionUnion
	function RegionUnion.new(...)
		local self = setmetatable({}, RegionUnion)
		return self:constructor(...) or self
	end
	function RegionUnion:constructor(regions)
		self.regions = regions
	end
	RegionUnion.enteredRegion = TS.async(function(self, part)
		local _fn = TS.Promise
		local _regions = self.regions
		local _arg0 = function(region)
			return region:enteredRegion(part)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_regions)
		for _k, _v in ipairs(_regions) do
			_newValue[_k] = _arg0(_v, _k - 1, _regions)
		end
		-- ▲ ReadonlyArray.map ▲
		return _fn.race(_newValue)
	end)
	RegionUnion.leftRegion = TS.async(function(self, part)
		local _fn = TS.Promise
		local _exp = self:isInRegions(part)
		local _arg0 = function(region)
			return region:leftRegion(part)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp)
		for _k, _v in ipairs(_exp) do
			_newValue[_k] = _arg0(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.map ▲
		return _fn.race(_newValue)
	end)
	function RegionUnion:isInRegions(part)
		local _regions = self.regions
		local _arg0 = function(region)
			return region:isInRegion(part)
		end
		-- ▼ ReadonlyArray.filter ▼
		local _newValue = {}
		local _length = 0
		for _k, _v in ipairs(_regions) do
			if _arg0(_v, _k - 1, _regions) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		-- ▲ ReadonlyArray.filter ▲
		return _newValue
	end
	function RegionUnion:isInRegion(part)
		local _regions = self.regions
		local _arg0 = function(region)
			return region:isInRegion(part)
		end
		-- ▼ ReadonlyArray.find ▼
		local _result = nil
		for _i, _v in ipairs(_regions) do
			if _arg0(_v, _i - 1, _regions) == true then
				_result = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _result
	end
end
return {
	BasePartRegion = BasePartRegion,
	SphereRegion = SphereRegion,
	RegionUnion = RegionUnion,
}
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="129">
        <Properties>
          <string name="Name">remotes</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Net = TS.import(script, TS.getModule(script, "@rbxts", "net").out)
local Remotes = Net.Definitions.Create({
	InSafezone = Net.Definitions.BidirectionalEvent(),
})
local default = Remotes
return {
	default = default,
}
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="130">
      <Properties>
        <string name="Name">Vendor</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="131">
      <Properties>
        <string name="Name">rbxts_include</string>
      </Properties>
      <Item class="ModuleScript" referent="132">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = {__mode = "k"}

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.
]]
local Error do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(errorStrings, table.concat({
				runtimeError.trace or runtimeError.error,
				runtimeError.context,
			}, "\n"))
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end


local function makeErrorHandler(traceback)
	assert(traceback ~= nil)

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", {"Started", "Resolved", "Rejected", "Cancelled"}),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
}
Promise.prototype = {}
Promise.__index = Promise.prototype

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(
			self._source,
			callback,
			resolve,
			reject,
			onCancel
		)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self:getStatus())
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.defer(callback)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, callback, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise._try(debug.traceback(nil, 2), ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					rejectedCount = rejectedCount + 1

					if amount == nil or #promises - rejectedCount < amount then
						cancel()
						done = true

						reject(...)
					end
				end
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

function Promise.fold(list, callback, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(type(callback) == "function", "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return callback(previousValueResolved, resolvedElement, i)
		end)
	end):andThenReturn(accumulator)
end

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, amount)
end

function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(
				function(...)
					resolveOne(i, ...)
				end
			)
		end
	end)
end

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[[
	Iterates serially over the given an array of values, calling the predicate callback on each before continuing.
	If the predicate returns a Promise, we wait for that Promise to resolve before continuing to the next item
	in the array. If the Promise the predicate returns rejects, the Promise from Promise.each is also rejected with
	the same value.

	Returns a Promise containing an array of the return values from the predicate for each item in the original list.
]]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(type(predicate) == "function", string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return type(object.andThen) == "function"
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and type(rawget(rawget(objectMetatable, "__index"), "andThen")) == "function"
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:catch")
	)
	return self:_andThen(debug.traceback(nil, 2), nil, failureCallback)
end

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:finally")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:done")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler, true)
end

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				local maybeRuntimeError = chainedPromise._values[1]

				-- Backwards compatibility < v2
				if chainedPromise._error then
					maybeRuntimeError = Error.new({
						error = chainedPromise._error,
						kind = Error.Kind.ExecutionError,
						context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
					})
				end

				if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
					return self:_reject(maybeRuntimeError:extend({
						error = "This Promise was chained to a Promise that errored.",
						trace = "",
						context = string.format(
							"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
							self._source
						),
					}))
				end

				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format(
				"Unhandled Promise rejection:\n\n%s\n\n%s",
				err,
				self._source
			)

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[[
	Chains a Promise from this one that is resolved if this Promise is
	resolved, and rejected if it is not resolved.
]]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self:getStatus() == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[[
	Retries a Promise-returning callback N times until it succeeds.
]]
function Promise.retry(callback, times, ...)
	assert(type(callback) == "function", "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = {...}, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[[
	Converts an event into a Promise with an optional predicate
]]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(function()
			disconnect()
		end)
	end)
end

return Promise
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="133">
        <Properties>
          <string name="Name">RuntimeLib</string>
          <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")
local ReplicatedFirst = game:GetService("ReplicatedFirst")

local TS = {}

TS.Promise = Promise

local function isPlugin(object)
	return RunService:IsStudio() and object:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(object, scope, moduleName)
	if moduleName == nil then
		moduleName = scope
		scope = "@rbxts"
	end

	if RunService:IsRunning() and object:IsDescendantOf(ReplicatedFirst) then
		warn("roblox-ts packages should not be used from ReplicatedFirst!")
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(object) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local globalModules = script.Parent:FindFirstChild("node_modules")
	if not globalModules then
		error("Could not find any modules!", 2)
	end

	repeat
		local modules = object:FindFirstChild("node_modules")
		if modules and modules ~= globalModules then
			modules = modules:FindFirstChild("@rbxts")
		end
		if modules then
			local module = modules:FindFirstChild(moduleName)
			if module then
				return module
			end
		end
		object = object.Parent
	until object == nil or object == globalModules

	local scopedModules = globalModules:FindFirstChild(scope or "@rbxts");
	return (scopedModules or globalModules):FindFirstChild(moduleName) or error("Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(caller, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error("Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[caller] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error("Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				"Invalid module access! Do you have two TS runtimes trying to import this? " .. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[caller] == module then -- Thread-safe cleanup!
		currentlyLoading[caller] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

function TS.bit_lrsh(a, b)
	local absA = math.abs(a)
	local result = bit32.rshift(absA, b)
	if a == absA then
		return result
	else
		return -result - 1
	end
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="134">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="135">
          <Properties>
            <string name="Name">compiler-types</string>
          </Properties>
          <Item class="ModuleScript" referent="136">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/compiler-types@^1.0.0-beta.15.1",
	_id = "@rbxts/compiler-types@1.0.0-types.0",
	_inBundle = false,
	_integrity = "sha512-DMYByLmapF5T04l1Jmg71BZNmR8sFhDt/aq9aV9X8JjnQimnCCBFK+FzdHh9Nx40D/o+k9vYn5aS58g8kISlYQ==",
	_location = "/@rbxts/compiler-types",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2fcompiler-types",
		fetchSpec = "^1.0.0-beta.15.1",
		name = "@rbxts/compiler-types",
		raw = "@rbxts/compiler-types@^1.0.0-beta.15.1",
		rawSpec = "^1.0.0-beta.15.1",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "range",
	},
	_requiredBy = {"#DEV:/", "#USER"},
	_resolved = "https://registry.npmjs.org/@rbxts/compiler-types/-/compiler-types-1.0.0-types.0.tgz",
	_shasum = "27e1cb297c9e96f4761f40fb24095f5a1c6881ec",
	_spec = "@rbxts/compiler-types@^1.0.0-beta.15.1",
	_where = "C:\\Users\\jhein\\Documents\\Github\\Mojave",
	author = {
		name = "roblox-ts",
	},
	bundleDependencies = false,
	deprecated = false,
	description = "",
	devDependencies = {
		["@rbxts/types"] = "^1.0.431",
		["@typescript-eslint/eslint-plugin"] = "^4.3.0",
		["@typescript-eslint/parser"] = "^4.3.0",
		eslint = "^7.11.0",
		["eslint-config-prettier"] = "^6.12.0",
		["eslint-plugin-prettier"] = "^3.1.4",
		prettier = "^2.1.2",
		typescript = "^4.0.3",
	},
	files = {"types/*.d.ts", "!types/stub.d.ts"},
	license = "MIT",
	main = "types/core.d.ts",
	name = "@rbxts/compiler-types",
	scripts = {
		eslint = "npx eslint \"types/**/*.d.ts\" --max-warnings 0",
	},
	types = "types/core.d.ts",
	version = "1.0.0-types.0",
}</string>
            </Properties>
          </Item>
          <Item class="Folder" referent="137">
            <Properties>
              <string name="Name">types</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="138">
          <Properties>
            <string name="Name">net</string>
          </Properties>
          <Item class="ModuleScript" referent="139">
            <Properties>
              <string name="Name">out</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local NetServerContext = TS.import(script, script, "server")
local NetClientContext = TS.import(script, script, "client")
local NetDefinitions = TS.import(script, script, "definitions").default
local NetMiddleware = TS.import(script, script, "middleware").NetMiddleware
local NetSerialization = TS.import(script, script, "serialization")
local BUILD_TYPE = "TS"
--[[
	*
	* Networking Library for Roblox
	* @version 2.0
]]
local Net = {}
do
	local _0 = Net
	--[[
		*
		* An object that contains a `Serialize` method.
		* @internal Still in development
	]]
	--[[
		*
		* A serialized representation of the object
		* @internal Still in development
	]]
	--[[
		*
		* Legacy client API for Net
	]]
	local Client = NetClientContext
	_0.Client = Client
	--[[
		*
		* Legacy server API for Net
	]]
	local Server = NetServerContext
	_0.Server = Server
	--[[
		*
		* The definitions API for Net
	]]
	local Definitions = NetDefinitions
	_0.Definitions = Definitions
	--[[
		*
		* The version of RbxNet
	]]
	local VERSION = "2.1.3" .. " (" .. ("production" == "development" and "DEV " .. BUILD_TYPE or BUILD_TYPE) .. ")"
	_0.VERSION = VERSION
	--[[
		*
		* Built-in middlewares
	]]
	local Middleware = NetMiddleware
	_0.Middleware = Middleware
	--[[
		*
		* Middleware function type for Net
	]]
	--[[
		*
		* Network serialization namespace
		* @internal Still in development
	]]
	local Serialization = NetSerialization
	_0.Serialization = Serialization
end
return Net
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="140">
              <Properties>
                <string name="Name">client</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ClientAsyncFunction").default
local Event = TS.import(script, script, "ClientEvent").default
local GameMessagingEvent = TS.import(script, script, "ClientMessagingEvent").default
local config = TS.import(script, script.Parent, "configuration")
local ClientEvent = TS.import(script, script, "ClientEvent").default
local ClientAsyncFunction = TS.import(script, script, "ClientAsyncFunction").default
local _0 = TS.import(script, script, "ClientFunction")
local ClientFunction = _0.default
local Function = _0.default
local SetConfiguration = config.SetClientConfiguration
local GetConfiguration = config.GetConfiguration
local function GetEvent(id)
	return ClientEvent.new(id)
end
local GetEventAsync = TS.async(function(id)
	return ClientEvent:Wait(id)
end)
local GetFunctionAsync = TS.async(function(id)
	return ClientFunction:Wait(id)
end)
local GetAsyncFunctionAsync = TS.async(function(id)
	return ClientAsyncFunction:Wait(id)
end)
local function GetAsyncFunction(id)
	return ClientAsyncFunction.new(id)
end
return {
	GetEvent = GetEvent,
	GetEventAsync = GetEventAsync,
	GetFunctionAsync = GetFunctionAsync,
	GetAsyncFunctionAsync = GetAsyncFunctionAsync,
	GetAsyncFunction = GetAsyncFunction,
	SetConfiguration = SetConfiguration,
	GetConfiguration = GetConfiguration,
	Event = Event,
	AsyncFunction = AsyncFunction,
	GameMessagingEvent = GameMessagingEvent,
	Function = Function,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="141">
                <Properties>
                  <string name="Name">ClientAsyncFunction</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "configuration")
local DebugLog = _0.DebugLog
local DebugWarn = _0.DebugWarn
local _1 = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _1.getRemoteOrThrow
local IS_SERVER = _1.IS_SERVER
local waitForRemote = _1.waitForRemote
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
--[[
	*
	* An event that behaves like a function
	* @rbxts client
]]
local ClientAsyncFunction
do
	ClientAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ClientAsyncFunction"
		end,
	})
	ClientAsyncFunction.__index = ClientAsyncFunction
	function ClientAsyncFunction.new(...)
		local self = setmetatable({}, ClientAsyncFunction)
		self:constructor(...)
		return self
	end
	function ClientAsyncFunction:constructor(name)
		self.timeout = 10
		self.listeners = {}
		self.instance = getRemoteOrThrow("AsyncRemoteFunction", name)
		local _2 = not IS_SERVER
		assert(_2, "Cannot create a Net.ClientAsyncFunction on the Server!")
	end
	function ClientAsyncFunction:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("AsyncRemoteFunction", name, 60))
			resolve(ClientAsyncFunction.new(name))
		end))
	end
	function ClientAsyncFunction:SetCallTimeout(timeout)
		local _2 = timeout > 0
		assert(_2, "timeout must be a positive number")
		self.timeout = timeout
	end
	function ClientAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ClientAsyncFunction:SetCallback(callback)
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		self.connector = self.instance.OnClientEvent:Connect(TS.async(function(...)
			local args = { ... }
			local _2 = args
			local eventId = _2[1]
			local data = _2[2]
			local _3 = eventId
			local _4 = type(_3) == "string"
			if _4 then
				local _5 = data
				_4 = type(_5) == "table"
			end
			if _4 then
				local result = callback(unpack(data))
				if TS.Promise.is(result) then
					local _5 = result
					local _6 = function(promiseResult)
						self.instance:FireServer(eventId, promiseResult)
					end
					_5:andThen(_6):catch(function(err)
						warn("[rbx-net] Failed to send response to server: " .. err)
					end)
				else
					self.instance:FireServer(eventId, result)
				end
			else
				warn("Recieved message without eventId")
			end
		end))
	end
	ClientAsyncFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		local id = HttpService:GenerateGUID(false)
		local _2 = self.instance
		local _3 = {}
		for _4, _5 in pairs(args) do
			_3[_4] = _5
		end
		_2:FireServer(id, _3)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			DebugLog("Connected CallServerAsync EventId", id)
			local connection
			connection = self.instance.OnClientEvent:Connect(function(...)
				local recvArgs = { ... }
				local _4 = recvArgs
				local eventId = _4[1]
				local data = _4[2]
				local _5 = eventId
				local _6 = type(_5) == "string"
				if _6 then
					_6 = data ~= nil
				end
				if _6 then
					if eventId == id then
						DebugLog("Disconnected CallServerAsync EventId", eventId)
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _4 = self.listeners
			local _5 = id
			local _6 = {
				connection = connection,
				timeout = self.timeout,
			}
			-- ▼ Map.set ▼
			_4[_5] = _6
			-- ▲ Map.set ▲
			repeat
				do
					RunService.Heartbeat:Wait()
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			local _7 = self.listeners
			local _8 = id
			-- ▼ Map.delete ▼
			_7[_8] = nil
			-- ▲ Map.delete ▲
			if tick() >= startTime and connection.Connected then
				DebugWarn("(timeout) Disconnected CallServerAsync EventId", id)
				connection:Disconnect()
				reject("Request to server timed out after " .. tostring(self.timeout) .. " seconds")
			end
		end)
	end)
end
return {
	default = ClientAsyncFunction,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="142">
                <Properties>
                  <string name="Name">ClientEvent</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _0.getRemoteOrThrow
local IS_SERVER = _0.IS_SERVER
local waitForRemote = _0.waitForRemote
--[[
	*
	* Interface for client listening events
]]
--[[
	*
	* Interface for client sender events
]]
local ClientEvent
do
	ClientEvent = setmetatable({}, {
		__tostring = function()
			return "ClientEvent"
		end,
	})
	ClientEvent.__index = ClientEvent
	function ClientEvent.new(...)
		local self = setmetatable({}, ClientEvent)
		self:constructor(...)
		return self
	end
	function ClientEvent:constructor(name)
		self.instance = getRemoteOrThrow("RemoteEvent", name)
		local _1 = not IS_SERVER
		assert(_1, "Cannot fetch NetClientEvent on the server!")
	end
	function ClientEvent:GetInstance()
		return self.instance
	end
	function ClientEvent:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteEvent", name, 60))
			resolve(ClientEvent.new(name))
		end))
	end
	function ClientEvent:SendToServer(...)
		local args = { ... }
		self.instance:FireServer(unpack(args))
	end
	function ClientEvent:Connect(callback)
		return self.instance.OnClientEvent:Connect(callback)
	end
end
local default = ClientEvent
return {
	default = default,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="143">
                <Properties>
                  <string name="Name">ClientFunction</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _0.getRemoteOrThrow
local IS_SERVER = _0.IS_SERVER
local waitForRemote = _0.waitForRemote
local ClientFunction
do
	ClientFunction = setmetatable({}, {
		__tostring = function()
			return "ClientFunction"
		end,
	})
	ClientFunction.__index = ClientFunction
	function ClientFunction.new(...)
		local self = setmetatable({}, ClientFunction)
		self:constructor(...)
		return self
	end
	function ClientFunction:constructor(name)
		self.instance = getRemoteOrThrow("RemoteFunction", name)
		local _1 = not IS_SERVER
		assert(_1, "Cannot create a Net.ClientFunction on the Server!")
	end
	function ClientFunction:Wait(name)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteFunction", name, 60))
			resolve(ClientFunction.new(name))
		end))
	end
	function ClientFunction:CallServer(...)
		local args = { ... }
		return self.instance:InvokeServer(unpack(args))
	end
	ClientFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		return TS.Promise.defer(function(resolve)
			local result = self.instance:InvokeServer(unpack(args))
			resolve(result)
		end)
	end)
end
return {
	default = ClientFunction,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="144">
                <Properties>
                  <string name="Name">ClientMessagingEvent</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local getGlobalRemoteId = TS.import(script, script.Parent.Parent, "internal").getGlobalRemote
local ClientEvent = TS.import(script, script.Parent, "ClientEvent").default
--[[
	*
	* Client counter-part to GlobalServerEvent
]]
local ClientMessagingEvent
do
	ClientMessagingEvent = setmetatable({}, {
		__tostring = function()
			return "ClientMessagingEvent"
		end,
	})
	ClientMessagingEvent.__index = ClientMessagingEvent
	function ClientMessagingEvent.new(...)
		local self = setmetatable({}, ClientMessagingEvent)
		self:constructor(...)
		return self
	end
	function ClientMessagingEvent:constructor(name)
		self.instance = ClientEvent.new(getGlobalRemoteId(name))
	end
	function ClientMessagingEvent:Connect(callback)
		self.instance:Connect(callback)
	end
end
return {
	default = ClientMessagingEvent,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="145">
              <Properties>
                <string name="Name">configuration</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local IS_CLIENT = TS.import(script, script.Parent, "internal").IS_CLIENT
local runService = game:GetService("RunService")
local IS_SERVER = runService:IsServer()
local Configuration = {
	ServerThrottleResetTimer = 60,
	EnableDebugMessages = "production" == "development",
	ServerThrottleMessage = "Request limit exceeded ({limit}) by {player} via {remote}",
}
local NetConfig = {}
do
	local _0 = NetConfig
	-- * @internal
	local DebugEnabled = "production" == "development"
	_0.DebugEnabled = DebugEnabled
	local function SetClient(config)
		local _1 = IS_CLIENT
		assert(_1, "Use SetClient on the client!")
		local _2 = {}
		for _3, _4 in pairs(Configuration) do
			_2[_3] = _4
		end
		for _3, _4 in pairs(config) do
			_2[_3] = _4
		end
		Configuration = _2
	end
	_0.SetClient = SetClient
	local function Set(config)
		local _1 = IS_SERVER
		assert(_1, "Use Set on the server!")
		local _2 = {}
		for _3, _4 in pairs(Configuration) do
			_2[_3] = _4
		end
		for _3, _4 in pairs(config) do
			_2[_3] = _4
		end
		Configuration = _2
	end
	_0.Set = Set
	local function Get()
		return Configuration
	end
	_0.Get = Get
	--[[
		*
		* @deprecated
		* @rbxts client
	]]
	local function SetClientConfiguration(key, value)
		local _1 = IS_CLIENT
		assert(_1, "Use SetConfiguration on the server!")
		if key == "EnableDebugMessages" then
			Configuration.EnableDebugMessages = value
		end
	end
	_0.SetClientConfiguration = SetClientConfiguration
	--[[
		*
		* @rbxts server
		* @deprecated
		*
	]]
	local function SetConfiguration(key, value)
		local _1 = IS_SERVER
		assert(_1, "Cannot set configuration on client!")
		Configuration[key] = value
	end
	_0.SetConfiguration = SetConfiguration
	--[[
		*
		* @deprecated
	]]
	local function GetConfiguration(key)
		return Configuration[key]
	end
	_0.GetConfiguration = GetConfiguration
	-- * @internal
	local function DebugWarn(...)
		local message = { ... }
		if DebugEnabled then
			warn("[rbx-net-debug]", unpack(message))
		end
	end
	_0.DebugWarn = DebugWarn
	-- * @internal
	local function DebugLog(...)
		local message = { ... }
		if DebugEnabled then
			print("[rbx-net-debug]", unpack(message))
		end
	end
	_0.DebugLog = DebugLog
end
return NetConfig
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="146">
              <Properties>
                <string name="Name">definitions</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
-- eslint-disable @typescript-eslint/no-explicit-any
local DeclarationTypeCheck = TS.import(script, script, "Types").DeclarationTypeCheck
local ServerDefinitionBuilder = TS.import(script, script, "ServerDefinitionBuilder").ServerDefinitionBuilder
local ClientDefinitionBuilder = TS.import(script, script, "ClientDefinitionBuilder").ClientDefinitionBuilder
local warnOnce = TS.import(script, script.Parent, "internal").warnOnce
local NamespaceBuilder = TS.import(script, script, "NamespaceBuilder").NamespaceBuilder
local NetDefinitions = {}
do
	local _0 = NetDefinitions
	--[[
		*
		* Validates the specified declarations to ensure they're valid before usage
		* @param declarations The declarations
	]]
	local function validateDeclarations(declarations)
		for _, declaration in pairs(declarations) do
			local _1 = DeclarationTypeCheck.check(declaration.Type)
			local _2 = DeclarationTypeCheck.errorMessage
			assert(_1, _2)
		end
	end
	--[[
		*
		* Creates definitions for Remote instances that can be used on both the client and server.
		* @description https://docs.vorlias.com/rbx-net/docs/2.0/definitions#definitions-oh-my
		* @param declarations
	]]
	local function Create(declarations, globalMiddleware)
		validateDeclarations(declarations)
		local _1 = {
			Server = ServerDefinitionBuilder.new(declarations, globalMiddleware),
			Client = ClientDefinitionBuilder.new(declarations),
		}
		return _1
	end
	_0.Create = Create
	--[[
		*
		* Defines a namespace of remote definitions, which can be retrieved via `GetNamespace(namespaceId)`
		*
		* E.g.
		* ```ts
		* const Remotes = Net.Definitions.Create({
		* 		ExampleGroup: Net.Definitions.Namespace({
		* 			ExampleGroupRemote: Net.Definitions.ServerToClientEvent<[message: string]>(),
		* 		}),
		* });
		* const ExampleGroupRemote = Remotes.Server.GetNamespace("ExampleGroup").Create("ExampleGroupRemote");
		* ```
		*
		* This is useful for categorizing remotes by feature.
	]]
	local function Namespace(declarations)
		return {
			Type = "Namespace",
			Definitions = NamespaceBuilder.new(declarations),
		}
	end
	_0.Namespace = Namespace
	--[[
		*
		* Defines a function in which strictly the client can call the server asynchronously
		*
		* `Client` [`Calls`] -> `Server` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Server` [`Responds to Call`] -> `Client` [`Recieves Response`]
	]]
	local function ServerAsyncFunction(mw)
		return {
			Type = "AsyncFunction",
			ServerMiddleware = mw,
		}
	end
	_0.ServerAsyncFunction = ServerAsyncFunction
	--[[
		*
		* Defines a function in which strictly the server can call the client asynchronously
		*
		* `Server` [`Calls`] -> `Client` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Client` [`Responds to Call`] -> `Server` [`Recieves Response`]
	]]
	local function ClientAsyncFunction()
		return {
			Type = "AsyncFunction",
		}
	end
	_0.ClientAsyncFunction = ClientAsyncFunction
	--[[
		*
		* Defines a regular function in which strictly the client can call the server synchronously
		*
		* (Synchronous) `Client` [`Calls`, `Recieves Response`] <- (yields for response) -> `Server` [`Recieves Call`, `Responds`]
	]]
	local function ServerFunction(mw)
		return {
			Type = "Function",
			ServerMiddleware = mw,
		}
	end
	_0.ServerFunction = ServerFunction
	--[[
		*
		* Defines an event in which strictly the server fires an event that is recieved by clients
		*
		* `Server` [`Sends`] => `Client(s)` [`Recieves`]
		*
		* On the client, this will give an event that can use `Connect`.
		*
		* On the server, this will give an event that can use `SendToPlayer`, `SendToAllPlayers`, `SendToAllPlayersExcept`
		*
	]]
	local function ServerToClientEvent()
		return {
			ServerMiddleware = {},
			Type = "Event",
		}
	end
	_0.ServerToClientEvent = ServerToClientEvent
	--[[
		*
		* Defines an event in which strictly clients fire an event that's recieved by the server
		*
		* `Client(s)` [`Sends`] => `Server` [`Recieves`]
		*
		* On the client, this will give an event that can use `SendToServer`.
		*
		* On the server, this will give an event that can use `Connect`.
		*
		* @param mw The middleware of this event.
	]]
	local function ClientToServerEvent(mw)
		return {
			Type = "Event",
			ServerMiddleware = mw,
		}
	end
	_0.ClientToServerEvent = ClientToServerEvent
	--[[
		*
		* Defines a remote event that can be fired both from the client and server
		*
		* This should only be required in rare use cases where `ClientToServerEvent` or `ServerToClientEvent` is not sufficient.
	]]
	local function BidirectionalEvent()
		return {
			Type = "Event",
			ServerMiddleware = {},
		}
	end
	_0.BidirectionalEvent = BidirectionalEvent
	-- / REGION deprecated members
	--[[
		*
		* Creates a definition for a function
		* @deprecated
	]]
	local function Function(mw)
		warnOnce("Definition '" .. "Function" .. "' is deprecated, use '" .. "ServerFunction" .. "' in your declarations - https://github.com/roblox-aurora/rbx-net/issues/35")
		return {
			Type = "Function",
			ServerMiddleware = mw,
		}
	end
	_0.Function = Function
	--[[
		*
		* Creates a definition for an event
		*
		*
		* ### If the event is fired by the client to the server, use `ClientToServerEvent`.
		* ### If the event is fired by the server to the client, use `ServerToClientEvent`.
		* ### If the event is both fired by client and server, use `BidirectionalEvent`.
		*
		* @deprecated This will be removed in future - please redesign your definitions
		*
	]]
	local function Event(mw)
		warnOnce("Definition '" .. "Event" .. "' is deprecated, use '" .. "ServerToClientEvent" .. "', '" .. "ClientToServerEvent" .. "' or '" .. "BidirectionalEvent" .. "' in your declarations - https://github.com/roblox-aurora/rbx-net/issues/35")
		return {
			Type = "Event",
			ServerMiddleware = mw,
		}
	end
	_0.Event = Event
	--[[
		*
		* Creates a definition for an async function
		*
		* ### If the function callback is on the server, use `AsyncServerFunction`.
		* ### If the function callback is on the client, use `AsyncClientFunction`.
		*
		* @deprecated This will be removed in future - please redesign your definitions
	]]
	local function AsyncFunction(mw)
		warnOnce("Definition '" .. "AsyncFunction" .. "' is deprecated, use '" .. "ServerAsyncFunction" .. "' or '" .. "ClientAsyncFunction" .. "' in your declarations - https://github.com/roblox-aurora/rbx-net/issues/35")
		return {
			Type = "AsyncFunction",
			ServerMiddleware = mw,
		}
	end
	_0.AsyncFunction = AsyncFunction
end
local default = NetDefinitions
return {
	default = default,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="147">
                <Properties>
                  <string name="Name">ClientDefinitionBuilder</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local ClientAsyncFunction = TS.import(script, script.Parent.Parent, "client", "ClientAsyncFunction").default
local ClientEvent = TS.import(script, script.Parent.Parent, "client", "ClientEvent").default
local ClientFunction = TS.import(script, script.Parent.Parent, "client", "ClientFunction").default
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local ClientDefinitionBuilder
do
	ClientDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ClientDefinitionBuilder"
		end,
	})
	ClientDefinitionBuilder.__index = ClientDefinitionBuilder
	function ClientDefinitionBuilder.new(...)
		local self = setmetatable({}, ClientDefinitionBuilder)
		self:constructor(...)
		return self
	end
	function ClientDefinitionBuilder:constructor(declarations, namespace)
		if namespace == nil then
			namespace = ""
		end
		self.namespace = namespace
		local _0 = declarationMap
		local _1 = self
		local _2 = declarations
		-- ▼ Map.set ▼
		_0[_1] = _2
		-- ▲ Map.set ▲
	end
	function ClientDefinitionBuilder:toString()
		return "[" .. "ClientDefinitionBuilder" .. "]"
	end
	function ClientDefinitionBuilder:Get(remoteId)
		local _0 = declarationMap
		local _1 = self
		local item = _0[_1][remoteId]
		local _2
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _3 = ":"
			if _3 == nil then
				_3 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_2 = (table.concat({ self.namespace, remoteId }, _3))
		else
			_2 = remoteId
		end
		remoteId = _2
		local _3 = item and item.Type
		local _4 = "'" .. remoteId .. "' is not defined in this definition."
		assert(_3, _4)
		if item.Type == "Function" then
			return ClientFunction.new(remoteId)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction.new(remoteId)
		elseif item.Type == "Event" then
			return ClientEvent.new(remoteId)
		end
		error("Invalid Type")
	end
	function ClientDefinitionBuilder:GetNamespace(groupName)
		local _0 = declarationMap
		local _1 = self
		local group = _0[_1][groupName]
		local _2 = group.Type == "Namespace"
		assert(_2)
		local _3 = group.Definitions
		local _4
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _5 = ":"
			if _5 == nil then
				_5 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_4 = table.concat({ self.namespace, groupName }, _5)
		else
			_4 = groupName
		end
		return _3:_buildClientDefinition(_4)
	end
	ClientDefinitionBuilder.WaitFor = TS.async(function(self, remoteId)
		local _0 = declarationMap
		local _1 = self
		local item = _0[_1][remoteId]
		local _2
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _3 = ":"
			if _3 == nil then
				_3 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_2 = (table.concat({ self.namespace, remoteId }, _3))
		else
			_2 = remoteId
		end
		remoteId = _2
		local _3 = item and item.Type
		local _4 = "'" .. remoteId .. "' is not defined in this definition."
		assert(_3, _4)
		if item.Type == "Function" then
			return ClientFunction:Wait(remoteId)
		elseif item.Type == "Event" then
			return ClientEvent:Wait(remoteId)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction:Wait(remoteId)
		end
		error("Invalid Type")
	end)
	function ClientDefinitionBuilder:OnEvent(name, fn)
		local result = self:Get(name)
		result:Connect(fn)
	end
	function ClientDefinitionBuilder:OnFunction(name, fn)
		local result = self:Get(name)
		result:SetCallback(fn)
	end
	function ClientDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ClientDefinitionBuilder = ClientDefinitionBuilder,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="148">
                <Properties>
                  <string name="Name">NamespaceBuilder</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local ClientDefinitionBuilder = TS.import(script, script.Parent, "ClientDefinitionBuilder").ClientDefinitionBuilder
local ServerDefinitionBuilder = TS.import(script, script.Parent, "ServerDefinitionBuilder").ServerDefinitionBuilder
local RunService = game:GetService("RunService")
-- Isolate the definitions since we don't need to access them anywhere else.
local declarationMap = setmetatable({}, {
	__mode = "k",
})
--[[
	*
	* A namespace builder. Internally used to construct definition builders
]]
local NamespaceBuilder
do
	NamespaceBuilder = setmetatable({}, {
		__tostring = function()
			return "NamespaceBuilder"
		end,
	})
	NamespaceBuilder.__index = NamespaceBuilder
	function NamespaceBuilder.new(...)
		local self = setmetatable({}, NamespaceBuilder)
		self:constructor(...)
		return self
	end
	function NamespaceBuilder:constructor(declarations)
		local _0 = declarationMap
		local _1 = self
		local _2 = declarations
		-- ▼ Map.set ▼
		_0[_1] = _2
		-- ▲ Map.set ▲
	end
	function NamespaceBuilder:_buildServerDefinition(globalMiddleware, namespace)
		local _0 = RunService:IsServer()
		assert(_0)
		local _1 = declarationMap
		local _2 = self
		return ServerDefinitionBuilder.new(_1[_2], globalMiddleware, namespace)
	end
	function NamespaceBuilder:_buildClientDefinition(namespace)
		local _0 = RunService:IsClient()
		assert(_0)
		local _1 = declarationMap
		local _2 = self
		return ClientDefinitionBuilder.new(_1[_2], namespace)
	end
end
return {
	NamespaceBuilder = NamespaceBuilder,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="149">
                <Properties>
                  <string name="Name">ServerDefinitionBuilder</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local ServerAsyncFunction = TS.import(script, script.Parent.Parent, "server", "ServerAsyncFunction").default
local ServerEvent = TS.import(script, script.Parent.Parent, "server", "ServerEvent").default
local ServerFunction = TS.import(script, script.Parent.Parent, "server", "ServerFunction").default
local CollectionService = game:GetService("CollectionService")
-- Tidy up all the types here.
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local remoteEventCache = {}
local remoteAsyncFunctionCache = {}
local remoteFunctionCache = {}
local ServerDefinitionBuilder
do
	ServerDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ServerDefinitionBuilder"
		end,
	})
	ServerDefinitionBuilder.__index = ServerDefinitionBuilder
	function ServerDefinitionBuilder.new(...)
		local self = setmetatable({}, ServerDefinitionBuilder)
		self:constructor(...)
		return self
	end
	function ServerDefinitionBuilder:constructor(declarations, globalMiddleware, namespace)
		if namespace == nil then
			namespace = ""
		end
		self.globalMiddleware = globalMiddleware
		self.namespace = namespace
		local _0 = declarationMap
		local _1 = self
		local _2 = declarations
		-- ▼ Map.set ▼
		_0[_1] = _2
		-- ▲ Map.set ▲
	end
	function ServerDefinitionBuilder:toString()
		return "[" .. "ServerDefinitionBuilder" .. "]"
	end
	function ServerDefinitionBuilder:OnEvent(name, fn)
		local result = self:Create(name)
		result:Connect(fn)
	end
	function ServerDefinitionBuilder:GetNamespace(groupId)
		local _0 = declarationMap
		local _1 = self
		local group = _0[_1][groupId]
		local _2 = group.Type == "Namespace"
		assert(_2)
		local _3 = group.Definitions
		local _4 = self.globalMiddleware
		local _5
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _6 = ":"
			if _6 == nil then
				_6 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_5 = table.concat({ self.namespace, groupId }, _6)
		else
			_5 = groupId
		end
		return _3:_buildServerDefinition(_4, _5)
	end
	function ServerDefinitionBuilder:Create(remoteId)
		local _0 = declarationMap
		local _1 = self
		local item = _0[_1][remoteId]
		local _2
		if self.namespace ~= "" then
			-- ▼ ReadonlyArray.join ▼
			local _3 = ":"
			if _3 == nil then
				_3 = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_2 = (table.concat({ self.namespace, remoteId }, _3))
		else
			_2 = remoteId
		end
		remoteId = _2
		local _3 = item and item.Type
		local _4 = "'" .. remoteId .. "' is not defined in this definition."
		assert(_3, _4)
		if item.Type == "Function" then
			local func
			-- This should make certain use cases cheaper
			local _5 = remoteFunctionCache
			local _6 = remoteId
			if _5[_6] ~= nil then
				local _7 = remoteFunctionCache
				local _8 = remoteId
				return _7[_8]
			else
				if item.ServerMiddleware then
					func = ServerFunction.new(remoteId, item.ServerMiddleware)
				else
					func = ServerFunction.new(remoteId)
				end
				CollectionService:AddTag(func:GetInstance(), "NetDefinitionManaged")
				local _7 = remoteFunctionCache
				local _8 = remoteId
				local _9 = func
				-- ▼ Map.set ▼
				_7[_8] = _9
				-- ▲ Map.set ▲
			end
			local _7 = self.globalMiddleware
			if _7 ~= nil then
				local _8 = function(mw)
					return func:_use(mw)
				end
				-- ▼ ReadonlyArray.forEach ▼
				for _9, _10 in ipairs(_7) do
					_8(_10, _9 - 1, _7)
				end
				-- ▲ ReadonlyArray.forEach ▲
			end
			return func
		elseif item.Type == "AsyncFunction" then
			local asyncFunction
			-- This should make certain use cases cheaper
			local _5 = remoteAsyncFunctionCache
			local _6 = remoteId
			if _5[_6] ~= nil then
				local _7 = remoteAsyncFunctionCache
				local _8 = remoteId
				return _7[_8]
			else
				if item.ServerMiddleware then
					asyncFunction = ServerAsyncFunction.new(remoteId, item.ServerMiddleware)
				else
					asyncFunction = ServerAsyncFunction.new(remoteId)
				end
				CollectionService:AddTag(asyncFunction:GetInstance(), "NetDefinitionManaged")
				local _7 = remoteAsyncFunctionCache
				local _8 = remoteId
				local _9 = asyncFunction
				-- ▼ Map.set ▼
				_7[_8] = _9
				-- ▲ Map.set ▲
			end
			local _7 = self.globalMiddleware
			if _7 ~= nil then
				local _8 = function(mw)
					return asyncFunction:_use(mw)
				end
				-- ▼ ReadonlyArray.forEach ▼
				for _9, _10 in ipairs(_7) do
					_8(_10, _9 - 1, _7)
				end
				-- ▲ ReadonlyArray.forEach ▲
			end
			return asyncFunction
		elseif item.Type == "Event" then
			local event
			-- This should make certain use cases cheaper
			local _5 = remoteEventCache
			local _6 = remoteId
			if _5[_6] ~= nil then
				local _7 = remoteEventCache
				local _8 = remoteId
				return _7[_8]
			else
				if item.ServerMiddleware then
					event = ServerEvent.new(remoteId, item.ServerMiddleware)
				else
					event = ServerEvent.new(remoteId)
				end
				CollectionService:AddTag(event:GetInstance(), "NetDefinitionManaged")
				local _7 = remoteEventCache
				local _8 = remoteId
				local _9 = event
				-- ▼ Map.set ▼
				_7[_8] = _9
				-- ▲ Map.set ▲
			end
			local _7 = self.globalMiddleware
			if _7 ~= nil then
				local _8 = function(mw)
					return event:_use(mw)
				end
				-- ▼ ReadonlyArray.forEach ▼
				for _9, _10 in ipairs(_7) do
					_8(_10, _9 - 1, _7)
				end
				-- ▲ ReadonlyArray.forEach ▲
			end
			return event
		end
		error("Invalid Type")
	end
	function ServerDefinitionBuilder:OnFunction(name, fn)
		local result = self:Create(name)
		result:SetCallback(fn)
	end
	function ServerDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ServerDefinitionBuilder = ServerDefinitionBuilder,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="150">
                <Properties>
                  <string name="Name">Types</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
--[[
	*
	* Types
	*
	* I will admit, this is a lot of type spaghetti. It makes the definitions work good though. :D
]]
local oneOf = TS.import(script, script.Parent.Parent, "internal", "validator").oneOf
--[[
	*
	* The DefinitionBuilders type
]]
--[[
	*
	* @deprecated
]]
--[[
	*
	* A declaration for an async client function
]]
--[[
	*
	* A declaration for an async server function
]]
-- * @deprecated
--[[
	*
	* A declaration for a client -> server event
]]
--[[
	*
	* A declaration for a server -> client event
]]
--[[
	*
	* A declaration for a Bidirectional event
]]
--[[
	*
	* A declaration group
]]
-- //////////////////////////////
-- * Inference Magic
-- /////////////////////////////
--[[
	*
	* This infers the client remote type based on the given value
]]
--[[
	*
	* This infers the server remote type based on the given value
]]
-- ///////////////////////////////////////
-- * Results
-- ///////////////////////////////////////
local DeclarationTypeCheck = oneOf("Event", "Function", "AsyncFunction", "Namespace")
return {
	DeclarationTypeCheck = DeclarationTypeCheck,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="151">
              <Properties>
                <string name="Name">internal</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local HttpService = game:GetService("HttpService")
local runService = game:GetService("RunService")
local collectionService = game:GetService("CollectionService")
-- * @internal
local IS_SERVER = not runService:IsRunning() or runService:IsServer()
-- * @internal
local IS_CLIENT = runService:IsRunning() and runService:IsClient()
local IS_RUNNING = runService:IsRunning()
-- * @internal
local MAX_CLIENT_WAITFORCHILD_TIMEOUT = 10
-- * @internal
local function getGlobalRemote(name)
	return ":\\" .. name
end
-- * @internal
local function isLuaTable(value)
	local _0 = value
	return type(_0) == "table"
end
-- * @internal
local NetMiddlewareEvent
do
	NetMiddlewareEvent = setmetatable({}, {
		__tostring = function()
			return "NetMiddlewareEvent"
		end,
	})
	NetMiddlewareEvent.__index = NetMiddlewareEvent
	function NetMiddlewareEvent.new(...)
		local self = setmetatable({}, NetMiddlewareEvent)
		self:constructor(...)
		return self
	end
	function NetMiddlewareEvent:constructor(netInstance)
		self.netInstance = netInstance
	end
	function NetMiddlewareEvent:GetInstance()
		return self.netInstance:GetInstance()
	end
end
local REMOTES_FOLDER_NAME = "_NetManaged"
-- * @internal
-- * @internal
local ServerTickFunctions = {}
-- * @internal
local function findOrCreateFolder(parent, name)
	local folder = parent:FindFirstChild(name)
	if folder then
		return folder
	else
		folder = Instance.new("Folder", parent)
		folder.Name = name
		return folder
	end
end
-- const dist = $env<"TS" | "Luau" | "TestTS">("TYPE", "TS");
local location = script.Parent
local remoteFolder = findOrCreateFolder(location, REMOTES_FOLDER_NAME)
--[[
	*
	* Errors with variables formatted in a message
	* @param message The message
	* @param vars variables to pass to the error message
]]
local function errorft(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _0 = message
	local _1 = function(token)
		local _2 = vars[token]
		if _2 == nil then
			_2 = token
		end
		return _2
	end
	local _2 = string.gsub(_0, "{([%w_][%w%d_]*)}", _1)
	message = _2[1]
	error(message, 2)
end
local traceSet = {}
local function warnOnce(message)
	local trace = debug.traceback()
	local _0 = traceSet
	local _1 = trace
	if _0[_1] ~= nil then
		return nil
	end
	local _2 = traceSet
	local _3 = trace
	-- ▼ Set.add ▼
	_2[_3] = true
	-- ▲ Set.add ▲
	warn("[rbx-net] " .. message)
end
local function format(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _0 = message
	local _1 = function(token)
		local _2 = vars[token]
		if _2 == nil then
			_2 = token
		end
		return _2
	end
	local _2 = string.gsub(_0, "{([%w_][%w%d_]*)}", _1)
	message = _2[1]
	return message
end
-- * @internal
local findRemote
local function waitForRemote(remoteType, name, timeout)
	return TS.Promise.defer(function(resolve, reject)
		local i = 0
		local result
		repeat
			do
				local step = runService.Heartbeat:Wait()
				i += step
				result = findRemote(remoteType, name)
			end
		until not (i < timeout and not result)
		if result then
			resolve(result)
		else
			reject("Timed out while waiting for " .. remoteType .. " '" .. name .. "' after " .. tostring(timeout) .. " seconds.")
		end
	end)
end
-- * @internal
function findRemote(remoteType, name)
	if remoteType == "AsyncRemoteFunction" then
		local _0 = collectionService:GetTagged("NetManagedAsyncFunction")
		local _1 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _2 = nil
		for _3, _4 in ipairs(_0) do
			if _1(_4, _3 - 1, _0) == true then
				_2 = _4
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _2
	elseif remoteType == "RemoteEvent" then
		local _0 = collectionService:GetTagged("NetManagedEvent")
		local _1 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _2 = nil
		for _3, _4 in ipairs(_0) do
			if _1(_4, _3 - 1, _0) == true then
				_2 = _4
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _2
	elseif remoteType == "RemoteFunction" then
		local _0 = collectionService:GetTagged("NetManagedLegacyFunction")
		local _1 = function(f)
			return f.Name == name
		end
		-- ▼ ReadonlyArray.find ▼
		local _2 = nil
		for _3, _4 in ipairs(_0) do
			if _1(_4, _3 - 1, _0) == true then
				_2 = _4
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		return _2
	end
	error("Invalid Remote Access")
end
-- * @internal
local function getRemoteOrThrow(remoteType, name)
	local existing = findRemote(remoteType, name)
	if existing then
		return existing
	else
		error("Could not find Remote of type " .. remoteType .. ' called "' .. name .. '"')
	end
end
-- * @internal
local function findOrCreateRemote(remoteType, name, onCreate)
	local existing = findRemote(remoteType, name)
	if existing then
		if collectionService:HasTag(existing, "NetDefinitionManaged") then
			warnOnce("Fetching " .. remoteType .. " '" .. name .. "', which is a DefinitionsManaged instance from a non-definitions context. This is considered unsafe.")
		end
		return existing
	else
		if not IS_SERVER then
			error("Creation of Events or Functions must be done on server!")
		end
		local remote
		if remoteType == "RemoteEvent" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedEvent")
		elseif remoteType == "AsyncRemoteFunction" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedAsyncFunction")
		elseif remoteType == "RemoteFunction" then
			remote = Instance.new("RemoteFunction")
			collectionService:AddTag(remote, "NetManagedLegacyFunction")
		else
			error("Invalid Remote Type: " .. remoteType)
		end
		remote.Name = name
		remote.Parent = remoteFolder
		local _0 = onCreate
		if _0 ~= nil then
			_0(remote)
		end
		return remote
	end
end
-- * @internal
local function checkArguments(types, args)
	if args == nil then
		warn("[net-types] Argument length is zero")
		return false
	end
	do
		local _0 = 0
		while _0 < #types do
			local i = _0
			local typeCheck = types[i + 1]
			local value = args[i + 1]
			if not typeCheck(value) then
				warn("[net-types] Argument at index " .. tostring(i) .. " was invalid type.")
				return false
			end
			_0 = i
			_0 += 1
		end
	end
	return true
end
if IS_SERVER then
	game:GetService("RunService").Stepped:Connect(function(time, step)
		for _, f in ipairs(ServerTickFunctions) do
			f()
		end
	end)
end
return {
	getGlobalRemote = getGlobalRemote,
	isLuaTable = isLuaTable,
	findOrCreateFolder = findOrCreateFolder,
	errorft = errorft,
	warnOnce = warnOnce,
	format = format,
	waitForRemote = waitForRemote,
	findRemote = findRemote,
	getRemoteOrThrow = getRemoteOrThrow,
	findOrCreateRemote = findOrCreateRemote,
	checkArguments = checkArguments,
	IS_SERVER = IS_SERVER,
	IS_CLIENT = IS_CLIENT,
	IS_RUNNING = IS_RUNNING,
	MAX_CLIENT_WAITFORCHILD_TIMEOUT = MAX_CLIENT_WAITFORCHILD_TIMEOUT,
	NetMiddlewareEvent = NetMiddlewareEvent,
	ServerTickFunctions = ServerTickFunctions,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="152">
                <Properties>
                  <string name="Name">tables</string>
                  <string name="Source">local function isMixed(t)
	assert(type(t) == "table")
	local mixed = false
	local _idxType

	for index, value in next, t do
		if _idxType and _idxType ~= type(index) then
			return true
		end

		_idxType = type(index)
		if type(value) == "table" then
			mixed = mixed and isMixed(value) and not (not getmetatable(value))
		end
	end

	return mixed
end

return {
	mixed = isMixed
}</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="153">
                <Properties>
                  <string name="Name">validator</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local isMixed = TS.import(script, script.Parent, "tables").isMixed
local Workspace = game:GetService("Workspace")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
-- * @internal
local isSerializable
local function validateArguments(...)
	local args = { ... }
	for index, value in ipairs(args) do
		if not isSerializable.check(value) then
			local _0 = isSerializable.errorMessage
			local _1 = index
			error(string.format(_0, _1), 2)
		end
		local _0 = value
		if typeof(_0) == "Instance" then
			if value:IsDescendantOf(ServerStorage) or value:IsDescendantOf(ServerScriptService) then
				error("[rbx-net] Instance at argument #" .. tostring(index) .. " is inside a server-only container and cannot be sent via remotes.")
			end
			if not value:IsDescendantOf(game) then
				error("[rbx-net] Instance at argument #" .. tostring(index) .. " is not a valid descendant of game, and wont replicate")
			end
		end
	end
end
-- * @internal
isSerializable = {
	errorMessage = "Argument #%d is not serializable. - see http://docs.vorlias.com/rbx-net/docs/2.0/serialization",
	check = function(value)
		-- Can't allow functions or threads
		local _0 = value
		local _1 = type(_0) == "function"
		if not _1 then
			local _2 = value
			_1 = type(_2) == "thread"
		end
		if _1 then
			return false
		end
		-- Can't allow metatabled objects
		local _2 = value
		local _3 = type(_2) == "table"
		if _3 then
			_3 = getmetatable(value) ~= nil
		end
		if _3 then
			return false
		end
		-- Ensure not a mixed table type
		local _4 = value
		if type(_4) == "table" then
			return not isMixed(value)
		end
		return true
	end,
}
-- * @internal
local function oneOf(...)
	local values = { ... }
	local _0 = {}
	local _1 = "errorMessage"
	-- ▼ ReadonlyArray.join ▼
	local _2 = ", "
	if _2 == nil then
		_2 = ", "
	end
	-- ▲ ReadonlyArray.join ▲
	_0[_1] = "Expected one of: " .. table.concat(values, _2)
	_0.check = function(value)
		local _3 = value
		if not (type(_3) == "string") then
			return false
		end
		for _, cmpValue in ipairs(values) do
			if value == cmpValue then
				return true
			end
		end
		return false
	end
	return _0
end
return {
	validateArguments = validateArguments,
	oneOf = oneOf,
	isSerializable = isSerializable,
}
]]></string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="154">
              <Properties>
                <string name="Name">messaging</string>
              </Properties>
              <Item class="ModuleScript" referent="155">
                <Properties>
                  <string name="Name">MessagingEvent</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local isLuaTable = _0.isLuaTable
local ServerTickFunctions = _0.ServerTickFunctions
-- const MessagingService = game.GetService("MessagingService");
local MessagingService = TS.import(script, script.Parent, "MessagingService")
local Players = game:GetService("Players")
local IS_STUDIO = game:GetService("RunService"):IsStudio()
--[[
	*
	* Checks if a value matches that of a subscription message
	* @param value The value
]]
local function isSubscriptionMessage(value)
	if isLuaTable(value) then
		local hasData = value.Data ~= nil
		return hasData
	else
		return false
	end
end
local function isJobTargetMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.jobId ~= nil
		end
	end
	return false
end
local globalMessageQueue = {}
local lastQueueTick = 0
local globalEventMessageCounter = 0
local globalSubscriptionCounter = 0
local MessagingEvent
local function processMessageQueue()
	if tick() >= lastQueueTick + 60 then
		globalEventMessageCounter = 0
		globalSubscriptionCounter = 0
		lastQueueTick = tick()
		while #globalMessageQueue > 0 do
			-- ▼ Array.pop ▼
			local _1 = #globalMessageQueue
			local _2 = globalMessageQueue[_1]
			globalMessageQueue[_1] = nil
			-- ▲ Array.pop ▲
			local message = _2
			MessagingService:PublishAsync(message.Name, message.Data)
			globalEventMessageCounter += 1
		end
		if globalEventMessageCounter >= MessagingEvent:GetMessageLimit() then
			warn("[rbx-net] Too many messages are being sent, any further messages will be queued!")
		end
	end
end
--[[
	*
	* Message Size: 1kB
	* MessagesPerMin: 150 + 60 * NUMPLAYERS
	* MessagesPerTopicMin: 30M
	* MessagesPerUniversePerMin: 30M
	* SubsPerServer: 5 + 2 * numPlayers
	* SubsPerUniverse: 10K
]]
--[[
	*
	* An event that works across all servers
	* @see https://developer.roblox.com/api-reference/class/MessagingService for limits, etc.
]]
do
	MessagingEvent = setmetatable({}, {
		__tostring = function()
			return "MessagingEvent"
		end,
	})
	MessagingEvent.__index = MessagingEvent
	function MessagingEvent.new(...)
		local self = setmetatable({}, MessagingEvent)
		self:constructor(...)
		return self
	end
	function MessagingEvent:constructor(name)
		self.name = name
	end
	function MessagingEvent:GetMessageLimit()
		return 150 + 60 * #Players:GetPlayers()
	end
	function MessagingEvent:GetSubscriptionLimit()
		return 5 + 2 * #Players:GetPlayers()
	end
	function MessagingEvent:sendToAllServersOrQueue(data)
		local limit = MessagingEvent:GetMessageLimit()
		if globalEventMessageCounter >= limit then
			warn("[rbx-net] Exceeded message limit of " .. tostring(limit) .. ", adding to queue...")
			local _1 = globalMessageQueue
			local _2 = {
				Name = self.name,
				Data = data,
			}
			-- ▼ Array.push ▼
			_1[#_1 + 1] = _2
			-- ▲ Array.push ▲
		else
			globalEventMessageCounter += 1
			-- Since this yields
			MessagingService:PublishAsync(self.name, data)
		end
	end
	function MessagingEvent:SendToServer(jobId, message)
		self:sendToAllServersOrQueue({
			jobId = jobId,
			message = message,
		})
	end
	function MessagingEvent:SendToAllServers(message)
		self:sendToAllServersOrQueue(message)
	end
	function MessagingEvent:Connect(handler)
		local limit = MessagingEvent:GetSubscriptionLimit()
		if globalSubscriptionCounter >= limit then
			error("[rbx-net] Exceeded Subscription limit of " .. tostring(limit) .. "!")
		end
		globalSubscriptionCounter += 1
		return MessagingService:SubscribeAsync(self.name, function(data, sent)
			local recieved = {
				Data = data,
				Sent = sent,
			}
			local _1 = recieved
			local Sent = _1.Sent
			if isJobTargetMessage(recieved) then
				local _2 = recieved
				local Data = _2.Data
				if game.JobId == Data.JobId then
					handler(Data.InnerData, Sent)
				end
			else
				handler(recieved.Data, Sent)
			end
		end)
	end
end
local _1 = ServerTickFunctions
local _2 = processMessageQueue
-- ▼ Array.push ▼
_1[#_1 + 1] = _2
-- ▲ Array.push ▲
return {
	isSubscriptionMessage = isSubscriptionMessage,
	default = MessagingEvent,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="156">
                <Properties>
                  <string name="Name">MessagingService</string>
                  <string name="Source">local RunService = game:GetService("RunService")
local MessagingService = game:GetService("MessagingService")

local MockMessagingService = {}
local topics = {}

function MockMessagingService:PublishAsync(topicName, message)
	local topic = topics[topicName]
	if topic then
		topic:Fire(
			{
				Sent = tick(),
				Data = message
			}
		)
	end
end

function MockMessagingService:SubscribeAsync(topicName, callback)
	local topic = topics[topicName]
	if not topic then
		topic = Instance.new("BindableEvent")
		topic.Parent = script
		topic.Name = topicName
		topics[topicName] = topic
	end

	return topic.Event:Connect(callback)
end

local service
if RunService:IsStudio() then
    service = MockMessagingService
else
    service = MessagingService
end


return service</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="157">
              <Properties>
                <string name="Name">middleware</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local createLoggerMiddleware = TS.import(script, script, "LoggerMiddleware")
local createRateLimiter = TS.import(script, script, "RateLimitMiddleware").default
local NetTypeCheckingMiddleware = TS.import(script, script, "TypeCheckMiddleware")
local NetMiddleware = {}
do
	local _0 = NetMiddleware
	local RateLimit = createRateLimiter
	_0.RateLimit = RateLimit
	local Logging = createLoggerMiddleware
	_0.Logging = Logging
	-- * The type checking middleware
	local TypeChecking = NetTypeCheckingMiddleware
	_0.TypeChecking = TypeChecking
	--[[
		*
		* Creates a global read-only middleware for use in `Net.Definitions` global middleware.
	]]
	local function Global(middleware)
		local _1 = function(processNext, event)
			return function(sender, ...)
				local args = { ... }
				middleware(event:GetInstance().Name, args, sender)
				return processNext(sender, unpack(args))
			end
		end
		return _1
	end
	_0.Global = Global
end
local createTypeChecker = NetTypeCheckingMiddleware
return {
	NetMiddleware = NetMiddleware,
	createRateLimiter = createRateLimiter,
	createTypeChecker = createTypeChecker,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="158">
                <Properties>
                  <string name="Name">LoggerMiddleware</string>
                  <string name="Source">local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio()

local function defaultLogger(name, args)
    if IS_STUDIO then
        local str = {};
        for _, arg in ipairs(args) do
            table.insert(str, HttpService:JSONEncode(arg))
        end
        print("[rbx-net] Called", name, "with arguments", "[ " .. table.concat(str, ", ") .. " ]")
    end
end

return function(options)
    options = options or {}
    local logger = options.Logger or defaultLogger

    return function (next, event)
        local name = options.Name or event:GetInstance().Name
        return function(player, ...)
            logger(name, {...})
            return next(player, ...)
        end
    end
end</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="159">
                <Properties>
                  <string name="Name">RateLimitMiddleware</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local format = _0.format
local IS_SERVER = _0.IS_SERVER
local ServerTickFunctions = _0.ServerTickFunctions
local throttler = TS.import(script, script, "throttle")
local GetConfiguration = TS.import(script, script.Parent.Parent, "configuration").GetConfiguration
local throttles = {}
local function rateLimitWarningHandler(rateLimitError)
	warn("[rbx-net]", rateLimitError.Message)
end
--[[
	*
	* Creates a throttle middleware for this event
	*
	* Will limit the amount of requests a player can make to this event
	*
	* _NOTE: Must be used before **other** middlewares as it's not a type altering middleware_
	* @param maxRequestsPerMinute The maximum requests per minute
]]
local function createRateLimiter(options)
	local maxRequestsPerMinute = options.MaxRequestsPerMinute
	local _1 = options.ErrorHandler
	if _1 == nil then
		_1 = rateLimitWarningHandler
	end
	local errorHandler = _1
	return function(processNext, event)
		local instance = event:GetInstance()
		local _2 = throttles
		local _3 = event
		local throttle = _2[_3]
		if throttle == nil then
			throttle = throttler:Get(instance:GetFullName())
		end
		return function(player, ...)
			local args = { ... }
			local count = throttle:Get(player)
			if count >= maxRequestsPerMinute then
				local _4 = errorHandler
				if _4 ~= nil then
					_4({
						Message = format(GetConfiguration("ServerThrottleMessage"), {
							player = player.UserId,
							remote = instance.Name,
							limit = maxRequestsPerMinute,
						}),
						MaxRequestsPerMinute = maxRequestsPerMinute,
						RemoteId = instance.Name,
						UserId = player.UserId,
					})
				end
			else
				throttle:Increment(player)
				return processNext(player, unpack(args))
			end
		end
	end
end
if IS_SERVER then
	local lastTick = 0
	local _1 = ServerTickFunctions
	local _2 = function()
		if tick() > lastTick + GetConfiguration("ServerThrottleResetTimer") then
			lastTick = tick()
			throttler:Clear()
		end
	end
	-- ▼ Array.push ▼
	_1[#_1 + 1] = _2
	-- ▲ Array.push ▲
end
local default = createRateLimiter
return {
	rateLimitWarningHandler = rateLimitWarningHandler,
	default = default,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="160">
                  <Properties>
                    <string name="Name">throttle</string>
                    <string name="Source"><![CDATA[local Throttle = {
	counters = {}
}
local RequestCounter = {}
RequestCounter.__index = RequestCounter

function RequestCounter.new()
	local self = {
		counter = {}
	}

	return setmetatable(self, RequestCounter)
end

function RequestCounter:Get(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]
	return playerQueue or 0
end

function RequestCounter:Increment(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]

	if not counter[player.UserId] then
		counter[player.UserId] = 1
	else
		counter[player.UserId] = playerQueue + 1
	end
end

function RequestCounter:__tostring()
	return "RequestCounter"
end

function RequestCounter:ClearAll()
	self.counter = {}
end

function Throttle:Get(name)
	local existing = self.counters[name]
	if (existing) then
		return existing
	else
		local newCounter = RequestCounter.new()
		self.counters[name] = newCounter
		return newCounter
	end
end

function Throttle:Clear()
	for _, counter in pairs(self.counters) do
		counter:ClearAll()
	end
end

return Throttle
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="161">
                <Properties>
                  <string name="Name">TypeCheckMiddleware</string>
                  <string name="Source">local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio();

local function defaultErrorHandler(event, args, index)
    local name = event:GetInstance().Name
    if IS_STUDIO then
        warn("[TypeCheckMiddleware] Call to " .. name .. " failed")
        warn("\tRecieved: " .. HttpService:JSONEncode(args))
        warn("\tInvalid argument at index " .. tostring(index))
    end
end

local MiddlewareGlobal = {}
MiddlewareGlobal.__index = MiddlewareGlobal
MiddlewareGlobal.defaultErrorHandler = defaultErrorHandler

local function typeCheckMiddleware(...)
    local checks = {...}
    local MiddlewareInstance = {}
    MiddlewareInstance.__index = MiddlewareInstance;

    function MiddlewareInstance:next(next, event)
        local errorHandler = self.errorHandler or MiddlewareGlobal.defaultErrorHandler
        --  what's returned as callbackFn
        return function(player, ...)
            local args = {...}
            for index, check in ipairs(checks) do
                if not check(args[index]) then
                    pcall(errorHandler, event, args, index)
                    return false
                end
            end

            -- Invoke the next middleware OR the callback (if none left)
            return next(player, ...)
        end
    end

    function MiddlewareInstance.__tostring()
        return "TypeCheckMiddleware"
    end

    function MiddlewareInstance:WithErrorHandler(fn)
        self.errorHandler = fn
        return self
    end

    function MiddlewareInstance:__call(...)
        return self:next(...)
    end
    
    return setmetatable({}, MiddlewareInstance)
    -- ^ The middleware
end

function MiddlewareGlobal.__call(_, ...)
    return typeCheckMiddleware(...)
end

function MiddlewareGlobal.SetDefaultErrorHandler(_, fn)
    MiddlewareGlobal.defaultErrorHandler = fn
end

return setmetatable({}, MiddlewareGlobal)</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="162">
              <Properties>
                <string name="Name">serialization</string>
                <string name="Source">local Serializer = {}

function Serializer.Serialize(object)
    if type(object) == "number" or type(object) == "string" or type(object) == "boolean" then
        return object
    end
    if type(object) ~= "table" then
        error("Cannot serialize type: " .. type(object), 2);
    end
    if object["Serialize"] ~= nil then
        return object:Serialize()
    end
    local serialized = {}
    for index, value in pairs(object) do
        if type(value) == "table" then
            serialized[index] = Serializer.Serialize(value)
        else
            serialized[index] = value;
        end
    end
    return serialized
end

local function isMixed(t)
	assert(type(t) == "table")
	local mixed = false
	local _idxType

	for index, value in next, t do
		if _idxType and _idxType ~= type(index) then
			return true
		end

		_idxType = type(index)
		if type(value) == "table" then
			mixed = mixed and isMixed(value) and not (not getmetatable(value))
		end
	end

	return mixed
end

function Serializer.IsSerializable(value)
    local _type = type(value)
	if _type == "number" or _type == "boolean" or _type == "string" then
		return true
	elseif _type == "table" then
		return not isMixed(value) and not getmetatable(value)
	elseif _type == "userdata" and typeof(_type) ~= "userdata" then -- Instances / Value Types
		return true
	else
		return false
	end
end

function Serializer.Deserialize(serialized, deserializer)
    assert(type(serialized) == "table")
    if deserializer then
        if type(deserializer) == "table" and deserializer["deserialize"] then
            return deserializer:deserialize(serialized)
        end
    end
end

return Serializer</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="163">
              <Properties>
                <string name="Name">server</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ServerAsyncFunction").default
local _0 = TS.import(script, script, "ServerEvent")
local ServerEvent = _0.default
local Event = _0.default
local GameMessagingEvent = TS.import(script, script, "ServerMessagingEvent").default
local CreateListener = TS.import(script, script, "CreateServerListener").default
local Function = TS.import(script, script, "ServerFunction").default
local config = TS.import(script, script.Parent, "configuration")
--[[
	*
	* Creates an event on the server
	*
	* Programmatically equivalent to `new Net.Server.Event(name, middleware)`
	*
	* @param name The name of the event
	* @param middleware The middleware attached to this event
]]
local function CreateEvent(name, middleware)
	return ServerEvent.new(name, middleware)
end
--[[
	*
	* Creates an event on the server
	* Same as `CreateEvent`, but type-wise removes `Connect`.
]]
local CreateSender = CreateEvent
--[[
	*
	* Creates a function on the server
	*
	* Programmatically equivalent to `new Net.Server.AsyncFunction(name, middleware)`
	*
	* @param name The name of the function
	* @param middleware The middleware attached to this function
]]
local function CreateAsyncFunction(name, middleware)
	if middleware == nil then
		middleware = {}
	end
	return AsyncFunction.new(name, middleware)
end
--[[
	*
	* An event declaration
]]
--[[
	*
	* Creates multiple server events by name, or declaration
	*
	* An example of a simple list of events is:
	*
	* ```ts
	* const [eventA, eventB] = Net.Server.CreateEvents("A", "B");
	* ```
	* Both `eventA` and `eventB` will be generic server events. If you want to include middleware, you can do:
	*
	* ```ts
	* const [eventA, middlewareEventB] = Net.Server.CreateEvents(
	* 	"A",
	* 	["B", createTypeChecker(t.string)]
	* )
	* ```
	* In this instance, it would be like doing `const middlewareEventB = new Net.Server.Event("B", [createTypeChecker(t.string)])`
	* Event A would still take any arguments, and Event B would take specific arguments (in this case, `string`)
]]
local function CreateEvents(...)
	local evts = { ... }
	local evtMap = {}
	for _, id in ipairs(evts) do
		local _1 = id
		if type(_1) == "string" then
			local _2 = evtMap
			local _3 = ServerEvent.new(id)
			-- ▼ Array.push ▼
			_2[#_2 + 1] = _3
			-- ▲ Array.push ▲
		else
			local _2 = id
			local name = _2[1]
			local middleware = { select(2, unpack(id)) }
			local _3 = evtMap
			local _4 = ServerEvent.new(name, middleware)
			-- ▼ Array.push ▼
			_3[#_3 + 1] = _4
			-- ▲ Array.push ▲
		end
	end
	return unpack(evtMap)
end
--[[
	*
	* Set a configuration value for the server
]]
local SetConfiguration = config.SetConfiguration
--[[
	*
	* Get a configuration value for the server
]]
local GetConfiguration = config.GetConfiguration
return {
	CreateEvent = CreateEvent,
	CreateAsyncFunction = CreateAsyncFunction,
	CreateEvents = CreateEvents,
	Event = Event,
	AsyncFunction = AsyncFunction,
	Function = Function,
	GameMessagingEvent = GameMessagingEvent,
	CreateListener = CreateListener,
	CreateSender = CreateSender,
	SetConfiguration = SetConfiguration,
	GetConfiguration = GetConfiguration,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="164">
                <Properties>
                  <string name="Name">CreateServerListener</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local ServerEventV2 = TS.import(script, script.Parent, "ServerEvent").default
local function isMiddlewareArgument(args)
	local _0 = #args > 1
	if _0 then
		local _1 = args[1]
		_0 = type(_1) == "table"
	end
	return _0
end
--[[
	*
	* Creates a server listening event
]]
local function createServerListener(id, ...)
	local args = { ... }
	local event
	if isMiddlewareArgument(args) then
		local _0 = args
		local middleware = _0[1]
		local connect = _0[2]
		event = ServerEventV2.new(id, middleware)
		return event:Connect(connect)
	else
		local _0 = args
		local connect = _0[1]
		event = ServerEventV2.new(id)
		return event:Connect(connect)
	end
end
return {
	default = createServerListener,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="165">
                <Properties>
                  <string name="Name">MiddlewareEvent</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
-- * @internal
local MiddlewareEvent
do
	MiddlewareEvent = {}
	function MiddlewareEvent:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareEvent:_use(middleware)
		local _0 = (self.middlewares)
		local _1 = middleware
		-- ▼ Array.push ▼
		_0[#_0 + 1] = _1
		-- ▲ Array.push ▲
	end
	function MiddlewareEvent:_processMiddleware(callback)
		local _0 = self
		local middlewares = _0.middlewares
		local _1, _2 = TS.try(function()
			local _3 = middlewares
			local _4 = type(_3) == "table"
			local _5 = middlewares
			local _6 = "The middleware argument should be an array of middlewares not a " .. typeof(_5)
			assert(_4, _6)
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _1 then
			return unpack(_2)
		end
	end
end
local default = MiddlewareEvent
return {
	default = default,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="166">
                <Properties>
                  <string name="Name">MiddlewareFunction</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local MiddlewareFunction
do
	MiddlewareFunction = {}
	function MiddlewareFunction:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareFunction:_use(middleware)
		local _0 = (self.middlewares)
		local _1 = middleware
		-- ▼ Array.push ▼
		_0[#_0 + 1] = _1
		-- ▲ Array.push ▲
	end
	function MiddlewareFunction:_processMiddleware(callback)
		local _0 = self
		local middlewares = _0.middlewares
		local _1, _2 = TS.try(function()
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _1 then
			return unpack(_2)
		end
	end
end
local default = MiddlewareFunction
return {
	default = default,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="167">
                <Properties>
                  <string name="Name">ServerAsyncFunction</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "configuration")
local DebugLog = _0.DebugLog
local DebugWarn = _0.DebugWarn
local _1 = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _1.findOrCreateRemote
local IS_CLIENT = _1.IS_CLIENT
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local function isEventArgs(value)
	if #value < 2 then
		return false
	end
	local _2 = value
	local eventId = _2[1]
	local data = _2[2]
	local _3 = eventId
	local _4 = type(_3) == "string"
	if _4 then
		local _5 = data
		_4 = type(_5) == "table"
	end
	return _4
end
--[[
	*
	* An asynchronous function for two way communication between the client and server
]]
local ServerAsyncFunction
do
	local super = MiddlewareEvent
	ServerAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ServerAsyncFunction"
		end,
		__index = super,
	})
	ServerAsyncFunction.__index = ServerAsyncFunction
	function ServerAsyncFunction.new(...)
		local self = setmetatable({}, ServerAsyncFunction)
		self:constructor(...)
		return self
	end
	function ServerAsyncFunction:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.timeout = 10
		self.listeners = {}
		self.instance = findOrCreateRemote("AsyncRemoteFunction", name, function(instance)
			-- Default connection
			self.defaultHook = instance.OnServerEvent:Connect(ServerAsyncFunction.DefaultEventHook)
		end)
		local _2 = not IS_CLIENT
		assert(_2, "Cannot create a NetServerAsyncFunction on the client!")
	end
	function ServerAsyncFunction:GetInstance()
		return self.instance
	end
	function ServerAsyncFunction:SetCallTimeout(timeout)
		local _2 = timeout > 0
		assert(_2, "timeout must be a positive number")
		self.timeout = timeout
		return self
	end
	function ServerAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ServerAsyncFunction:SetCallback(callback)
		local _2 = self.defaultHook
		if _2 ~= nil then
			_2:Disconnect()
		end
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		self.connector = self.instance.OnServerEvent:Connect(TS.async(function(player, ...)
			local args = { ... }
			if isEventArgs(args) then
				local _3 = args
				local eventId = _3[1]
				local data = _3[2]
				local _4 = self:_processMiddleware(callback)
				if _4 ~= nil then
					_4 = _4(player, unpack(data))
				end
				local result = _4
				if TS.Promise.is(result) then
					local _5 = result
					local _6 = function(promiseResult)
						self.instance:FireClient(player, eventId, promiseResult)
					end
					_5:andThen(_6):catch(function(err)
						warn("[rbx-net] Failed to send response to client: " .. err)
					end)
				else
					if result == nil then
						warn("[rbx-net-async] " .. self.instance.Name .. " returned undefined")
					end
					self.instance:FireClient(player, eventId, result)
				end
			else
				warn("[rbx-net-async] Recieved message without eventId")
			end
		end))
	end
	ServerAsyncFunction.CallPlayerAsync = TS.async(function(self, player, ...)
		local args = { ... }
		local id = HttpService:GenerateGUID(false)
		local _2 = self.instance
		local _3 = {}
		for _4, _5 in pairs(args) do
			_3[_4] = _5
		end
		_2:FireClient(player, id, _3)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			DebugLog("Connected CallPlayerAsync EventId", id)
			local connection
			connection = self.instance.OnServerEvent:Connect(function(fromPlayer, ...)
				local recvArgs = { ... }
				local _4 = recvArgs
				local eventId = _4[1]
				local data = _4[2]
				local _5 = eventId
				local _6 = type(_5) == "string"
				if _6 then
					_6 = data ~= nil
				end
				if _6 then
					if player == player and eventId == id then
						DebugLog("Disconnected CallPlayerAsync EventId", eventId)
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _4 = self.listeners
			local _5 = id
			local _6 = {
				connection = connection,
				timeout = self.timeout,
			}
			-- ▼ Map.set ▼
			_4[_5] = _6
			-- ▲ Map.set ▲
			repeat
				do
					RunService.Stepped:Wait()
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			local _7 = self.listeners
			local _8 = id
			-- ▼ Map.delete ▼
			_7[_8] = nil
			-- ▲ Map.delete ▲
			if tick() >= startTime and connection.Connected then
				DebugWarn("(timeout) Disconnected CallPlayerAsync EventId", id)
				connection:Disconnect()
				reject("Request to client timed out")
			end
		end)
	end)
	ServerAsyncFunction.DefaultEventHook = function(player, ...)
		local args = { ... }
	end
end
local default = ServerAsyncFunction
return {
	default = default,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="168">
                <Properties>
                  <string name="Name">ServerEvent</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _0.findOrCreateRemote
local IS_CLIENT = _0.IS_CLIENT
local IS_RUNNING = _0.IS_RUNNING
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
--[[
	*
	* Interface for server listening events
]]
--[[
	*
	* Interface for server sender events
]]
local ServerEvent
do
	local super = MiddlewareEvent
	ServerEvent = setmetatable({}, {
		__tostring = function()
			return "ServerEvent"
		end,
		__index = super,
	})
	ServerEvent.__index = ServerEvent
	function ServerEvent.new(...)
		local self = setmetatable({}, ServerEvent)
		self:constructor(...)
		return self
	end
	function ServerEvent:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.instance = findOrCreateRemote("RemoteEvent", name, function(instance)
			-- Default connection
			self.defaultHook = instance.OnServerEvent:Connect(ServerEvent.DefaultEventHook)
		end)
		local _1 = not IS_CLIENT
		assert(_1, "Cannot create a NetServerEvent on the client!")
	end
	function ServerEvent:GetInstance()
		return self.instance
	end
	function ServerEvent:Connect(callback)
		local _1 = self.defaultHook
		if _1 ~= nil then
			_1:Disconnect()
		end
		local connection = self.instance.OnServerEvent:Connect(function(player, ...)
			local args = { ... }
			local _2 = self:_processMiddleware(callback)
			if _2 ~= nil then
				_2(player, unpack(args))
			end
		end)
		return connection
	end
	function ServerEvent:SendToAllPlayers(...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireAllClients(unpack(args))
	end
	function ServerEvent:SendToAllPlayersExcept(blacklist, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		local Players = game:GetService("Players")
		local _1 = blacklist
		if typeof(_1) == "Instance" then
			local _2 = Players:GetPlayers()
			local _3 = function(p)
				return p ~= blacklist
			end
			-- ▼ ReadonlyArray.filter ▼
			local _4 = {}
			local _5 = 0
			for _6, _7 in ipairs(_2) do
				if _3(_7, _6 - 1, _2) == true then
					_5 += 1
					_4[_5] = _7
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			local otherPlayers = _4
			for _, player in ipairs(otherPlayers) do
				self.instance:FireClient(player, unpack(args))
			end
		else
			local _2 = blacklist
			if type(_2) == "table" then
				for _, player in ipairs(Players:GetPlayers()) do
					local _3 = blacklist
					local _4 = player
					if (table.find(_3, _4) or 0) - 1 == -1 then
						self.instance:FireClient(player, unpack(args))
					end
				end
			end
		end
	end
	function ServerEvent:SendToPlayer(player, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireClient(player, unpack(args))
	end
	function ServerEvent:SendToPlayers(players, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		for _, player in ipairs(players) do
			self:SendToPlayer(player, unpack(args))
		end
	end
	ServerEvent.DefaultEventHook = function(player, ...)
		local args = { ... }
	end
end
return {
	default = ServerEvent,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="169">
                <Properties>
                  <string name="Name">ServerFunction</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _0.findOrCreateRemote
local IS_SERVER = _0.IS_SERVER
local MiddlewareFunction = TS.import(script, script.Parent, "MiddlewareFunction").default
local ServerFunction
do
	local super = MiddlewareFunction
	ServerFunction = setmetatable({}, {
		__tostring = function()
			return "ServerFunction"
		end,
		__index = super,
	})
	ServerFunction.__index = ServerFunction
	function ServerFunction.new(...)
		local self = setmetatable({}, ServerFunction)
		self:constructor(...)
		return self
	end
	function ServerFunction:constructor(name, middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.instance = findOrCreateRemote("RemoteFunction", name, function(instance)
			-- Default listener
			instance.OnServerInvoke = ServerFunction.DefaultFunctionHook
		end)
		local _1 = IS_SERVER
		assert(_1, "Cannot create a Net.ServerFunction on the Client!")
	end
	function ServerFunction:GetInstance()
		return self.instance
	end
	function ServerFunction:SetCallback(callback)
		self.instance.OnServerInvoke = function(player, ...)
			local args = { ... }
			local _1 = self:_processMiddleware(callback)
			if _1 ~= nil then
				_1 = _1(player, unpack(args))
			end
			local result = _1
			if TS.Promise.is(result) then
				warn("[rbx-net] WARNING: Promises should be used with an AsyncFunction!")
				local success, value = result:await()
				if success then
					return value
				else
					error(value)
				end
			end
			return result
		end
	end
	ServerFunction.DefaultFunctionHook = function()
		-- TODO: 2.2 make usable for analytics?
		-- Although, unlike `Event`, this will need to be part of `SetCallback`'s stuff.
		return nil
	end
end
return {
	default = ServerFunction,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="170">
                <Properties>
                  <string name="Name">ServerMessagingEvent</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _0 = TS.import(script, script.Parent.Parent, "messaging", "MessagingEvent")
local MessagingEvent = _0.default
local isSubscriptionMessage = _0.isSubscriptionMessage
local _1 = TS.import(script, script.Parent.Parent, "internal")
local getGlobalRemote = _1.getGlobalRemote
local IS_CLIENT = _1.IS_CLIENT
local isLuaTable = _1.isLuaTable
local ServerEvent = TS.import(script, script.Parent, "ServerEvent").default
local Players = game:GetService("Players")
local function isTargetedSubscriptionMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.InnerData ~= nil
		end
	end
	return false
end
--[[
	*
	* Similar to a ServerEvent, but works across all servers.
]]
local ServerMessagingEvent
do
	ServerMessagingEvent = setmetatable({}, {
		__tostring = function()
			return "ServerMessagingEvent"
		end,
	})
	ServerMessagingEvent.__index = ServerMessagingEvent
	function ServerMessagingEvent.new(...)
		local self = setmetatable({}, ServerMessagingEvent)
		self:constructor(...)
		return self
	end
	function ServerMessagingEvent:constructor(name)
		self.instance = ServerEvent.new(getGlobalRemote(name))
		self.event = MessagingEvent.new(name)
		local _2 = not IS_CLIENT
		assert(_2, "Cannot create a Net.GlobalServerEvent on the Client!")
		self.eventHandler = self.event:Connect(function(message)
			if isTargetedSubscriptionMessage(message) then
				self:recievedMessage(message.Data)
			else
				warn("[rbx-net] Recieved malformed message for ServerGameEvent: " .. name)
			end
		end)
	end
	function ServerMessagingEvent:getPlayersMatchingId(matching)
		local _2 = matching
		if type(_2) == "number" then
			return Players:GetPlayerByUserId(matching)
		else
			local players = {}
			for _, id in ipairs(matching) do
				local player = Players:GetPlayerByUserId(id)
				if player then
					local _3 = players
					local _4 = player
					-- ▼ Array.push ▼
					_3[#_3 + 1] = _4
					-- ▲ Array.push ▲
				end
			end
			return players
		end
	end
	function ServerMessagingEvent:recievedMessage(message)
		if message.TargetIds then
			local players = self:getPlayersMatchingId(message.TargetIds)
			if players then
				self.instance:SendToPlayers(players, unpack(message.InnerData))
			end
		elseif message.TargetId ~= nil then
			local player = self:getPlayersMatchingId(message.TargetId)
			if player then
				self.instance:SendToPlayer(player, unpack(message.InnerData))
			end
		else
			self.instance:SendToAllPlayers(unpack(message.InnerData))
		end
	end
	function ServerMessagingEvent:Disconnect()
		self.eventHandler:Disconnect()
	end
	function ServerMessagingEvent:SendToAllServers(...)
		local args = { ... }
		local _2 = self.event
		local _3 = {}
		local _4 = "data"
		local _5 = {}
		local _6 = #_5
		for _7, _8 in ipairs(args) do
			_5[_6 + _7] = _8
		end
		_3[_4] = _5
		_2:SendToAllServers(_3)
	end
	function ServerMessagingEvent:SendToServer(jobId, ...)
		local args = { ... }
		local _2 = self.event
		local _3 = {}
		local _4 = "data"
		local _5 = {}
		local _6 = #_5
		for _7, _8 in ipairs(args) do
			_5[_6 + _7] = _8
		end
		_3[_4] = _5
		_2:SendToServer(jobId, _3)
	end
	function ServerMessagingEvent:SendToPlayer(userId, ...)
		local args = { ... }
		local player = Players:GetPlayerByUserId(userId)
		-- If the player exists in this instance, just send it straight to them.
		if player then
			self.instance:SendToPlayer(player, unpack(args))
		else
			local _2 = self.event
			local _3 = {}
			local _4 = "data"
			local _5 = {}
			local _6 = #_5
			for _7, _8 in ipairs(args) do
				_5[_6 + _7] = _8
			end
			_3[_4] = _5
			_3.targetId = userId
			_2:SendToAllServers(_3)
		end
	end
	function ServerMessagingEvent:SendToPlayers(userIds, ...)
		local args = { ... }
		-- Check to see if any of these users are in this server first, and handle accordingly.
		for _, targetId in ipairs(userIds) do
			local player = Players:GetPlayerByUserId(targetId)
			if player then
				self.instance:SendToPlayer(player, unpack(args))
				local _2 = userIds
				local _3 = targetId
				table.remove(_2, _3 + 1)
			end
		end
		if #userIds > 0 then
			local _2 = self.event
			local _3 = {}
			local _4 = "data"
			local _5 = {}
			local _6 = #_5
			for _7, _8 in ipairs(args) do
				_5[_6 + _7] = _8
			end
			_3[_4] = _5
			_3.targetIds = userIds
			_2:SendToAllServers(_3)
		end
	end
end
return {
	default = ServerMessagingEvent,
}
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="171">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/net",
	_id = "@rbxts/net@2.1.3",
	_inBundle = false,
	_integrity = "sha512-AebQubpow0ABCXJ+U2+QvrvCjpYyWOfvcbGfmu8jR0AS/Dyl5eNXRoqWmb8w5NOQnXgZSS0QAlwim/pdJnyyOg==",
	_location = "/@rbxts/net",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2fnet",
		fetchSpec = "latest",
		name = "@rbxts/net",
		raw = "@rbxts/net",
		rawSpec = "",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "tag",
	},
	_requiredBy = {"#USER", "/"},
	_resolved = "https://registry.npmjs.org/@rbxts/net/-/net-2.1.3.tgz",
	_shasum = "bee94f6fd929cccfef4016b971209b9e9be36e29",
	_spec = "@rbxts/net",
	_where = "C:\\Users\\jhein\\Documents\\Github\\Mojave",
	author = "",
	bugs = {
		url = "https://github.com/roblox-aurora/rbx-net/issues",
	},
	bundleDependencies = false,
	dependencies = {
	},
	deprecated = false,
	description = "![](logo.png) RbxNet v2.1 =========== Advanced multi-language networking library for Roblox. -----",
	devDependencies = {
		["@rbxts/compiler-types"] = "^1.1.1-types.3",
		["@rbxts/t"] = "^1.3.5",
		["@rbxts/types"] = "^1.0.471",
		["@typescript-eslint/eslint-plugin"] = "^4.9.0",
		["@typescript-eslint/parser"] = "^4.9.0",
		concurrently = "^6.0.0",
		["cross-env"] = "^7.0.3",
		eslint = "^7.14.0",
		["eslint-config-prettier"] = "^6.15.0",
		["eslint-plugin-prettier"] = "^3.2.0",
		["eslint-plugin-roblox-ts"] = "0.0.24",
		prettier = "^2.2.1",
		["rbxts-transform-debug"] = "^0.4.0",
		["rbxts-transform-env"] = "^0.3.0",
		typescript = "^4.1.2",
	},
	homepage = "https://github.com/roblox-aurora/rbx-net#readme",
	keywords = {},
	license = "MIT",
	main = "out/init.lua",
	name = "@rbxts/net",
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-aurora/rbx-net.git",
	},
	scripts = {
		build = "cross-env NODE_ENV=production rbxtsc --verbose",
		["build:dev"] = "cross-env NODE_ENV=development rbxtsc --verbose",
		["build:docs"] = "cd docs &amp;&amp; npm run build",
		["build:example"] = "cross-env NODE_ENV=development rbxtsc-dev --type=game -p ./example -i ./include",
		["build:luau"] = "cross-env NODE_ENV=production TYPE=Luau rbxtsc --verbose --type=model --rojo=\"luau/build.project.json\"",
		["build:rbxmx"] = "npm run build:luau &amp;&amp; rojo build luau/build.project.json -o luau.net.rbxmx",
		["dev:example"] = "concurrently npm:watch:example npm:serve:example",
		prepare = "npm run build",
		["serve:example"] = "rojo serve ./example/default.project.json --port 34567",
		["start:docs"] = "cd docs &amp;&amp; yarn start",
		["watch:example"] = "cross-env NODE_ENV=development TYPE=TestTS rbxtsc-dev -w --type=game -p ./example -i ./include",
	},
	types = "out/index.d.ts",
	version = "2.1.3",
}</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="172">
          <Properties>
            <string name="Name">object-event</string>
            <string name="Source"><![CDATA[--[[
    File: init.lua
    Author: davness
    Year: 2019
    License: MIT

    This file acts as a runtime for the ObjectEvent described in the index file.
--]]

-- Declare existance of our classes
local ObjectEvent, ObjectEventConnection

ObjectEvent = setmetatable({}, {
    __tostring = function() return "ObjectEvent"; end
})

ObjectEvent.__index = ObjectEvent

function ObjectEvent.new(...)
    local self = setmetatable({}, ObjectEvent)
    self.SubscribedConnections = {}
    self.YieldQueue = {}

    return self
end;

function ObjectEvent:Connect(f)
    return ObjectEventConnection.new(f, self)
end

function ObjectEvent:Wait()
    table.insert(self.YieldQueue, coroutine.running())
    return coroutine.yield()
end

function ObjectEvent:Fire(...)
    local args = {...}

    -- Activate all listeners
    for _, c in pairs(self.SubscribedConnections) do
        coroutine.resume(coroutine.create(function()
            c.Listener(unpack(args))
        end))
    end

    -- Resume all yielding threads on :Wait()
    for _, t in pairs(self.YieldQueue) do
        coroutine.resume(t, unpack(args))
    end

    -- Reset the yielding queue.
    self.YieldQueue = {}
end

ObjectEventConnection = setmetatable({}, {
__tostring = function() return "EventConnection"; end
})


ObjectEventConnection.__index = ObjectEventConnection

function ObjectEventConnection.new(toConnect, event)
    local self = setmetatable({}, ObjectEventConnection)
    self.Listener = toConnect
    self.Event = event
    self.Enabled = false
    -- Forcing reconnect should do the trick
    self:Reconnect()

    return self
end

function ObjectEventConnection:IsConnected()
    return self.Enabled;
end

function ObjectEventConnection:Disconnect()
    local subscribers = self.Event.SubscribedConnections
    local index = table.find(subscribers, self)

    if not index then
        warn("Attempted to disconnect an event that wasn't connected at all. Exiting.", 0)
        return nil
    end

    table.remove(subscribers, index)
    self.Enabled = false
end

function ObjectEventConnection:Reconnect()
    local subscribers = self.Event.SubscribedConnections
    local index = table.find(subscribers, self)

    if index then
        warn("Attempted to reconnect an event that is already connected. Exiting.", 0)
        return nil
    end

    table.insert(subscribers, self);
    self.Enabled = true;
end

return ObjectEvent
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="173">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/object-event",
	_id = "@rbxts/object-event@1.0.1",
	_inBundle = false,
	_integrity = "sha512-yMDlltKhW35Dz8Wr7tSSMGP1G1nJ+ARHb2CyDvGd1XzP92aBo5xdy7nl3UUOz1WOEXIpBbMlMOqRBp4ElEebSA==",
	_location = "/@rbxts/object-event",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2fobject-event",
		fetchSpec = "latest",
		name = "@rbxts/object-event",
		raw = "@rbxts/object-event",
		rawSpec = "",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "tag",
	},
	_requiredBy = {"#USER", "/"},
	_resolved = "https://registry.npmjs.org/@rbxts/object-event/-/object-event-1.0.1.tgz",
	_shasum = "9736af6a4f22f55775725de997f0aac0b542032a",
	_spec = "@rbxts/object-event",
	_where = "C:\\Users\\jhein\\Documents\\GitHub\\Mojave",
	author = {
		name = "davness",
	},
	bugs = {
		url = "https://github.com/ddavness/roblox-object-event/issues",
	},
	bundleDependencies = false,
	dependencies = {
		["@rbxts/types"] = "^1.0.462",
	},
	deprecated = false,
	description = "Allows for custom events to be created for custom OOP implementations. Attempts to reproduce Roblox's syntax as closely as possible while adding more features.",
	devDependencies = {
		["@rbxts/types"] = "^1.0.462",
		["@typescript-eslint/eslint-plugin"] = "^4.17.0",
		["@typescript-eslint/parser"] = "^4.17.0",
		eslint = "^7.21.0",
		["eslint-config-prettier"] = "^8.1.0",
		["eslint-plugin-prettier"] = "^3.3.1",
		["eslint-plugin-roblox-ts"] = "^0.0.25",
		prettier = "^2.2.1",
		typescript = "^4.2.3",
	},
	files = {"*.lua", "*.d.ts"},
	homepage = "https://github.com/ddavness/roblox-object-event",
	keywords = {"Roblox", "TypeScript", "Roblox-TS", "ObjectEvent", "OOP", "Event", "Signal", "Connection"},
	license = "MIT",
	main = "init.lua",
	name = "@rbxts/object-event",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/ddavness/roblox-object-event.git",
	},
	types = "index.d.ts",
	version = "1.0.1",
}</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="174">
          <Properties>
            <string name="Name">roact</string>
          </Properties>
          <Item class="ModuleScript" referent="175">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/roact",
	_id = "@rbxts/roact@1.3.0-ts.14",
	_inBundle = false,
	_integrity = "sha512-gyv8xWWzD0tbn1qTfjPatW5svMMu2a4f8LwQE/2ufmYMyMnqLUZTjqnd/G7SobGTU3y5SjN8XWXZAkeziQt2Dg==",
	_location = "/@rbxts/roact",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2froact",
		fetchSpec = "latest",
		name = "@rbxts/roact",
		raw = "@rbxts/roact",
		rawSpec = "",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "tag",
	},
	_requiredBy = {"#USER", "/"},
	_resolved = "https://registry.npmjs.org/@rbxts/roact/-/roact-1.3.0-ts.14.tgz",
	_shasum = "8a354016a14d263382af8ae22020d877b8f292d8",
	_spec = "@rbxts/roact",
	_where = "C:\\Users\\jhein\\Documents\\Github\\Mojave",
	author = "",
	bundleDependencies = false,
	contributors = {{
		name = "Jonathan Holmes",
		url = "https://github.com/Vorlias",
	}},
	dependencies = {
	},
	deprecated = false,
	description = "TypeScript support for Roact",
	devDependencies = {
		["@rbxts/compiler-types"] = "^1.0.0-types.0",
		["@rbxts/types"] = "^1.0.459",
	},
	files = {"src", "!src/test.tsx"},
	keywords = {"roblox", "typescript", "roact"},
	licenses = {{
		type = "Apache 2.0",
		url = "https://github.com/Roblox/roact/blob/master/LICENSE",
	}},
	main = "src/init.lua",
	name = "@rbxts/roact",
	scripts = {
	},
	typings = "src/index.d.ts",
	version = "1.3.0-ts.14",
}</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="176">
            <Properties>
              <string name="Name">src</string>
              <string name="Source">--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict {
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,
	createContext = require(script.createContext),

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {
	},
}

return Roact</string>
            </Properties>
            <Item class="ModuleScript" referent="177">
              <Properties>
                <string name="Name">Binding</string>
                <string name="Source">local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = (
					"Expected arg #1 to contain only bindings, but key %q had a non-binding value"
				):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="178">
              <Properties>
                <string name="Name">Component</string>
                <string name="Source">local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, rendering, or unmounting, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate or
		lifecyclePhase == ComponentLifecyclePhase.WillUpdate or
		lifecyclePhase == ComponentLifecyclePhase.Render or
		lifecyclePhase == ComponentLifecyclePhase.WillUnmount
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.DidMount or
		lifecyclePhase == ComponentLifecyclePhase.DidUpdate or
		lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)

	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)

	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(
		tostring(internalData.componentClass)
	)

	error(message, 0)
end

--[[
	Retrieves the context value corresponding to the given key. Can return nil
	if a requested context key is not present
]]
function Component:__getContext(key)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getContext`")
		internalAssert(key ~= nil, "Context key cannot be nil")
	end

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

--[[
	Adds a new context entry to this component's context table (which will be
	passed down to child components).
]]
function Component:__addContext(key, value)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__addContext`")
	end
	local virtualNode = self[InternalData].virtualNode

	-- Make sure we store a reference to the component's original, unmodified
	-- context the virtual node. In the reconciler, we'll restore the original
	-- context if we need to replace the node (this happens when a node gets
	-- re-rendered as a different component)
	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	-- Build a new context table on top of the existing one, then apply it to
	-- our virtualNode
	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
			typeof(validator),
			self.__componentName
		))
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "&lt;Validator function did not supply a message>"
		error(("Property validation failed in %s: %s\n\n%s"):format(
			self.__componentName,
			tostring(failureReason),
			self:getElementTraceback() or "&lt;enable element tracebacks>"),
		0)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="179">
              <Properties>
                <string name="Name">ComponentLifecyclePhase</string>
                <string name="Source">local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="180">
              <Properties>
                <string name="Name">Config</string>
                <string name="Source">--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = (
				"Invalid global configuration key %q. Valid configuration keys are: %s"
			):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = (
				"Invalid global configuration key %q (type %s). Valid configuration keys are: %s"
			):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(
				tostring(value),
				typeof(value),
				tostring(key)
			)

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="181">
              <Properties>
                <string name="Name">ElementKind</string>
                <string name="Source">--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="182">
              <Properties>
                <string name="Name">ElementUtils</string>
                <string name="Source">local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements(elementOrElements)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function()
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return noop
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="183">
              <Properties>
                <string name="Name">GlobalConfig</string>
                <string name="Source">--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="184">
              <Properties>
                <string name="Name">Logging</string>
                <string name="Source">--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = {"LogInfo {"}

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="185">
              <Properties>
                <string name="Name">None</string>
                <string name="Source">local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="186">
              <Properties>
                <string name="Name">NoopRenderer</string>
                <string name="Source">--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(reconciler, node)
end

function NoopRenderer.unmountHostNode(reconciler, node)
end

function NoopRenderer.updateHostNode(reconciler, node, newElement)
	return node
end

return NoopRenderer</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="187">
              <Properties>
                <string name="Name">Portal</string>
                <string name="Source">local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal</string>
              </Properties>
            </Item>
            <Item class="Folder" referent="188">
              <Properties>
                <string name="Name">PropMarkers</string>
              </Properties>
              <Item class="ModuleScript" referent="189">
                <Properties>
                  <string name="Name">Change</string>
                  <string name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="190">
                <Properties>
                  <string name="Name">Children</string>
                  <string name="Source">local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="191">
                <Properties>
                  <string name="Name">Event</string>
                  <string name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="192">
                <Properties>
                  <string name="Name">Ref</string>
                  <string name="Source">local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="193">
              <Properties>
                <string name="Name">PureComponent</string>
                <string name="Source">--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="194">
              <Properties>
                <string name="Name">RobloxRenderer</string>
                <string name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(
			typeof(ref)
		))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="195">
              <Properties>
                <string name="Name">SingleEventManager</string>
                <string name="Source">--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(
			tostring(key),
			event
		), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index &lt;= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="196">
              <Properties>
                <string name="Name">Symbol</string>
                <string name="Source">--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="197">
              <Properties>
                <string name="Name">Type</string>
                <string name="Source">--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="198">
              <Properties>
                <string name="Name">assertDeepEqual</string>
                <string name="Source">--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a, b)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(
			typeof(a),
			typeof(b)
		)
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true
	end

	if a == b then
		return true
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success then
		local innerMessage = innerMessageTemplate
			:gsub("{1}", "first")
			:gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="199">
              <Properties>
                <string name="Name">assign</string>
                <string name="Source">local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="200">
              <Properties>
                <string name="Name">createContext</string>
                <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local createFragment = require(script.Parent.createFragment)
local createSignal = require(script.Parent.createSignal)
local Children = require(script.Parent.PropMarkers.Children)
local Component = require(script.Parent.Component)

--[[
	Construct the value that is assigned to Roact's context storage.
]]
local function createContextEntry(currentValue)
	return {
		value = currentValue,
		onUpdate = createSignal(),
	}
end

local function createProvider(context)
	local Provider = Component:extend("Provider")

	function Provider:init(props)
		self.contextEntry = createContextEntry(props.value)
		self:__addContext(context.key, self.contextEntry)
	end

	function Provider:willUpdate(nextProps)
		-- If the provided value changed, immediately update the context entry.
		--
		-- During this update, any components that are reachable will receive
		-- this updated value at the same time as any props and state updates
		-- that are being applied.
		if nextProps.value ~= self.props.value then
			self.contextEntry.value = nextProps.value
		end
	end

	function Provider:didUpdate(prevProps)
		-- If the provided value changed, after we've updated every reachable
		-- component, fire a signal to update the rest.
		--
		-- This signal will notify all context consumers. It's expected that
		-- they will compare the last context value they updated with and only
		-- trigger an update on themselves if this value is different.
		--
		-- This codepath will generally only update consumer components that has
		-- a component implementing shouldUpdate between them and the provider.
		if prevProps.value ~= self.props.value then
			self.contextEntry.onUpdate:fire(self.props.value)
		end
	end

	function Provider:render()
		return createFragment(self.props[Children])
	end

	return Provider
end

local function createConsumer(context)
	local Consumer = Component:extend("Consumer")

	function Consumer.validateProps(props)
		if type(props.render) ~= "function" then
			return false, "Consumer expects a `render` function"
		else
			return true
		end
	end

	function Consumer:init(props)
		-- This value may be nil, which indicates that our consumer is not a
		-- descendant of a provider for this context item.
		self.contextEntry = self:__getContext(context.key)
	end

	function Consumer:render()
		-- Render using the latest available for this context item.
		--
		-- We don't store this value in state in order to have more fine-grained
		-- control over our update behavior.
		local value
		if self.contextEntry ~= nil then
			value = self.contextEntry.value
		else
			value = context.defaultValue
		end

		return self.props.render(value)
	end

	function Consumer:didUpdate()
		-- Store the value that we most recently updated with.
		--
		-- This value is compared in the contextEntry onUpdate hook below.
		if self.contextEntry ~= nil then
			self.lastValue = self.contextEntry.value
		end
	end

	function Consumer:didMount()
		if self.contextEntry ~= nil then
			-- When onUpdate is fired, a new value has been made available in
			-- this context entry, but we may have already updated in the same
			-- update cycle.
			--
			-- To avoid sending a redundant update, we compare the new value
			-- with the last value that we updated with (set in didUpdate) and
			-- only update if they differ. This may happen when an update from a
			-- provider was blocked by an intermediate component that returned
			-- false from shouldUpdate.
			self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)
				if newValue ~= self.lastValue then
					-- Trigger a dummy state update.
					self:setState({})
				end
			end)
		end
	end

	function Consumer:willUnmount()
		if self.disconnect ~= nil then
			self.disconnect()
		end
	end

	return Consumer
end

local Context = {}
Context.__index = Context

function Context.new(defaultValue)
	return setmetatable({
		defaultValue = defaultValue,
		key = Symbol.named("ContextKey"),
	}, Context)
end

function Context:__tostring()
	return "RoactContext"
end

local function createContext(defaultValue)
	local context = Context.new(defaultValue)

	return {
		Provider = createProvider(context),
		Consumer = createConsumer(context),
	}
end

return createContext
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="201">
              <Properties>
                <string name="Name">createElement</string>
                <string name="Source">local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overriden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="202">
              <Properties>
                <string name="Name">createFragment</string>
                <string name="Source">local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="203">
              <Properties>
                <string name="Name">createReconciler</string>
                <string name="Source"><![CDATA[local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and legacyContext from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth

		-- If the node that is being replaced has modified context, we need to
		-- use the original *unmodified* context for the new node
		-- The `originalContext` field will be nil if the context was unchanged
		local context = virtualNode.originalContext or virtualNode.context
		local parentLegacyContext = virtualNode.parentLegacyContext

		unmountVirtualNode(virtualNode)
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(
					newElement,
					hostParent,
					concreteKey,
					virtualNode.context,
					virtualNode.legacyContext
				)

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element
			or renderResult == nil
			or typeof(renderResult) == "boolean"
		then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(("%s\n%s"):format(
				"Component returned invalid children:",
				virtualNode.currentElement.source or "<enable element tracebacks>"
			), 0)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		local kind = ElementKind.of(virtualNode.currentElement)

		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,

			-- Legacy Context API
			-- A table of context values inherited from the parent node
			legacyContext = legacyContext,

			-- A saved copy of the parent context, used when replacing a node
			parentLegacyContext = legacyContext,

			-- Context API
			-- A table of context values inherited from the parent node
			context = context or {},

			-- A saved copy of the unmodified context; this will be updated when
			-- a component adds new context and used when a node is replaced
			originalContext = nil,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind), 2))
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="204">
              <Properties>
                <string name="Name">createReconcilerCompat</string>
                <string name="Source">--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="205">
              <Properties>
                <string name="Name">createRef</string>
                <string name="Source">--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="206">
              <Properties>
                <string name="Name">createSignal</string>
                <string name="Source">--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function addToMap(map, addKey, addValue)
	local new = {}

	for key, value in pairs(map) do
		new[key] = value
	end

	new[addKey] = addValue

	return new
end

local function removeFromMap(map, removeKey)
	local new = {}

	for key, value in pairs(map) do
		if key ~= removeKey then
			new[key] = value
		end
	end

	return new
end

local function createSignal()
	local connections = {}

	local function subscribe(self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
		}

		connections = addToMap(connections, callback, connection)

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections = removeFromMap(connections, callback)
		end

		return disconnect
	end

	local function fire(self, ...)
		for callback, connection in pairs(connections) do
			if not connection.disconnected then
				callback(...)
			end
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="207">
              <Properties>
                <string name="Name">createSpy</string>
                <string name="Source">--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {
		callCount = 0,
		values = {},
		valuesLength = 0,
	}

	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = {...}
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(
				self.valuesLength,
				len
			), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="208">
              <Properties>
                <string name="Name">getDefaultInstanceProperty</string>
                <string name="Source">--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="209">
              <Properties>
                <string name="Name">internalAssert</string>
                <string name="Source">local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="210">
              <Properties>
                <string name="Name">invalidSetStateMessages</string>
                <string name="Source">--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.WillUnmount] = [[
setState cannot be used in the willUnmount lifecycle method.
A component that is being unmounted cannot be updated!

Check the definition of willUnmount in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="211">
              <Properties>
                <string name="Name">oneChild</string>
                <string name="Source">--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="212">
              <Properties>
                <string name="Name">strict</string>
                <string name="Source">local function strict(t, name)
	name = name or tostring(t)

	return setmetatable(t, {
		__index = function(self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,

		__newindex = function(self, key, value)
			local message = ("%q (%s) is not a valid member of %s"):format(
				tostring(key),
				typeof(key),
				name
			)

			error(message, 2)
		end,
	})
end

return strict</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="213">
          <Properties>
            <string name="Name">rotatedregion3</string>
            <string name="Source"><![CDATA[-- TAKEN FROM https://www.roblox.com/library/3686163417/Rotated-Region3-GJK
-- PACKAGE UPDATED SINCE MAY 02, 2020 12:15:45 PM

--[[
This is a Rotated Region3 Class that behaves much the same as the standard Region3 class expect that it allows
for both rotated regions and also a varying array of shapes.	
API:
Constructors:
	RotatedRegion3.new(CFrame cframe, Vector3 size)
		> Creates a region from a cframe which acts as the center of the region and size which extends to 
		> the corners like a block part.
	RotatedRegion3.Block(CFrame cframe, Vector3 size)
		> This is the exact same as the region.new constructor, but has a different name.
	RotatedRegion3.Wedge(CFrame cframe, Vector3 size)
		> Creates a region from a cframe which acts as the center of the region and size which extends to 
		> the corners like a wedge part.
	RotatedRegion3.CornerWedge(CFrame cframe, Vector3 size)
		> Creates a region from a cframe which acts as the center of the region and size which extends to 
		> the corners like a cornerWedge part.
	RotatedRegion3.Cylinder(CFrame cframe, Vector3 size)
		> Creates a region from a cframe which acts as the center of the region and size which extends to 
		> the corners like a cylinder part.
	RotatedRegion3.Ball(CFrame cframe, Vector3 size)
		> Creates a region from a cframe which acts as the center of the region and size which extends to 
		> the corners like a ball part.
	RotatedRegion3.FromPart(part)
		> Creates a region from a part in the game. It can be used on any base part, but the region 
		> will treat unknown shapes (meshes, unions, etc) as block shapes.
Methods:
	RotatedRegion3:CastPoint(Vector3 point)
		> returns true or false if the point is within the RotatedRegion3 object
	RotatedRegion3:CastPart(BasePart part)
		> returns true or false if the part is withing the RotatedRegion3 object
	RotatedRegion3:FindPartsInRegion3(Instance ignore, Integer maxParts)
		> returns array of parts in the RotatedRegion3 object
		> will return a maximum number of parts in array [maxParts] the default is 20
		> parts that either are descendants of or actually are the [ignore] instance will be ignored
	RotatedRegion3:FindPartsInRegion3WithIgnoreList(Instance Array ignore, Integer maxParts)
		> returns array of parts in the RotatedRegion3 object
		> will return a maximum number of parts in array [maxParts] the default is 20
		> parts that either are descendants of the [ignore array] or actually are the [ignore array] instances will be ignored
	RotatedRegion3:FindPartsInRegion3WithWhiteList(Instance Array whiteList, Integer maxParts)
		> returns array of parts in the RotatedRegion3 object
		> will return a maximum number of parts in array [maxParts] the default is 20
		> parts that either are descendants of the [whiteList array] or actually are the [whiteList array] instances are all that will be checked
	RotatedRegion3:Cast(Instance or Instance Array ignore, Integer maxParts)
		> Same as the `:FindPartsInRegion3WithIgnoreList` method, but will check if the ignore argument is an array or single instance
Properties:
	RotatedRegion3.CFrame
		> cframe that represents the center of the region
	RotatedRegion3.Size
		> vector3 that represents the size of the region
	RotatedRegion3.Shape
		> string that represents the shape type of the RotatedRegion3 object
	RotatedRegion3.Set
		> array of vector3 that are passed to the support function
	RotatedRegion3.Support
		> function that is used for support in the GJK algorithm
	RotatedRegion3.Centroid
		> vector3 that represents the center of the set, again used for the GJK algorithm
	RotatedRegion3.AlignedRegion3
		> standard region3 that represents the world bounding box of the RotatedRegion3 object
Note: I haven't actually done anything to enforce this, but you should treat all these properties as read only
Enjoy!
- EgoMoose
--]]
--
local GJK = require(script:WaitForChild("GJK"))
local Supports = require(script:WaitForChild("Supports"))
local Vertices = require(script:WaitForChild("Vertices"))
-- Class
local RotatedRegion3 = {}
RotatedRegion3.__index = RotatedRegion3
-- Private functions
local function getCorners(cf, s2)
	return {
		cf:PointToWorldSpace(Vector3.new(-s2.x, s2.y, s2.z));
		cf:PointToWorldSpace(Vector3.new(-s2.x, -s2.y, s2.z));
		cf:PointToWorldSpace(Vector3.new(-s2.x, -s2.y, -s2.z));
		cf:PointToWorldSpace(Vector3.new(s2.x, -s2.y, -s2.z));
		cf:PointToWorldSpace(Vector3.new(s2.x, s2.y, -s2.z));
		cf:PointToWorldSpace(Vector3.new(s2.x, s2.y, s2.z));
		cf:PointToWorldSpace(Vector3.new(s2.x, -s2.y, s2.z));
		cf:PointToWorldSpace(Vector3.new(-s2.x, s2.y, -s2.z));
	}
end
local function worldBoundingBox(set)
	local x, y, z = {}, {}, {}
	for i = 1, #set do x[i], y[i], z[i] = set[i].x, set[i].y, set[i].z end
	local min = Vector3.new(math.min(unpack(x)), math.min(unpack(y)), math.min(unpack(z)))
	local max = Vector3.new(math.max(unpack(x)), math.max(unpack(y)), math.max(unpack(z)))
	return min, max
end
-- Public Constructors
function RotatedRegion3.new(cframe, size)
	local self = setmetatable({}, RotatedRegion3)
	
	self.CFrame = cframe
	self.Size = size
	self.Shape = "Block"
	
	self.Set = Vertices.Block(cframe, size/2)
	self.Support = Supports.PointCloud
	self.Centroid = cframe.p
	
	self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))
	return self
end
RotatedRegion3.Block = RotatedRegion3.new
function RotatedRegion3.Wedge(cframe, size)
	local self = setmetatable({}, RotatedRegion3)
	self.CFrame = cframe
	self.Size = size
	self.Shape = "Wedge"
	
	self.Set = Vertices.Wedge(cframe, size/2)
	self.Support = Supports.PointCloud
	self.Centroid = Vertices.GetCentroid(self.Set)
	
	self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))
	return self
end
function RotatedRegion3.CornerWedge(cframe, size)
	local self = setmetatable({}, RotatedRegion3)
	self.CFrame = cframe
	self.Size = size
	self.Shape = "CornerWedge"
	
	self.Set = Vertices.CornerWedge(cframe, size/2)
	self.Support = Supports.PointCloud
	self.Centroid = Vertices.GetCentroid(self.Set)
	
	self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))
	return self
end
function RotatedRegion3.Cylinder(cframe, size)
	local self = setmetatable({}, RotatedRegion3)
	self.CFrame = cframe
	self.Size = size
	self.Shape = "Cylinder"
	
	self.Set = {cframe, size/2}
	self.Support = Supports.Cylinder
	self.Centroid = cframe.p
	
	self.AlignedRegion3 = Region3.new(worldBoundingBox(getCorners(unpack(self.Set))))
	return self
end
function RotatedRegion3.Ball(cframe, size)
	local self = setmetatable({}, RotatedRegion3)
	self.CFrame = cframe
	self.Size = size
	self.Shape = "Ball"
	
	self.Set = {cframe, size/2}
	self.Support = Supports.Ellipsoid
	self.Centroid = cframe.p
	
	self.AlignedRegion3 = Region3.new(worldBoundingBox(getCorners(unpack(self.Set))))
	return self
end
function RotatedRegion3.FromPart(part)
	return RotatedRegion3[Vertices.Classify(part)](part.CFrame, part.Size)
end
-- Public Constructors
function RotatedRegion3:CastPoint(point)
	local gjk = GJK.new(self.Set, {point}, self.Centroid, point, self.Support, Supports.PointCloud)
	return gjk:IsColliding()
end
function RotatedRegion3:CastPart(part)
	local r3 = RotatedRegion3.FromPart(part)
	local gjk = GJK.new(self.Set, r3.Set, self.Centroid, r3.Centroid, self.Support, r3.Support)
	return gjk:IsColliding()
end
function RotatedRegion3:FindPartsInRegion3(ignore, maxParts)
	local found = {}
	local parts = game.Workspace:FindPartsInRegion3(self.AlignedRegion3, ignore, maxParts)
	for i = 1, #parts do
		if (self:CastPart(parts[i])) then
			table.insert(found, parts[i])
		end
	end
	return found
end
function RotatedRegion3:FindPartsInRegion3WithIgnoreList(ignore, maxParts)
	ignore = ignore or {}
	local found = {}
	local parts = game.Workspace:FindPartsInRegion3WithIgnoreList(self.AlignedRegion3, ignore, maxParts)
	for i = 1, #parts do
		if (self:CastPart(parts[i])) then
			table.insert(found, parts[i])
		end
	end
	return found
end
function RotatedRegion3:FindPartsInRegion3WithWhiteList(whiteList, maxParts)
	whiteList = whiteList or {}
	local found = {}
	local parts = game.Workspace:FindPartsInRegion3WithWhiteList(self.AlignedRegion3, whiteList, maxParts)
	for i = 1, #parts do
		if (self:CastPart(parts[i])) then
			table.insert(found, parts[i])
		end
	end
	return found
end
function RotatedRegion3:Cast(ignore, maxParts)
	ignore = type(ignore) == "table" and ignore or {ignore}
	return self:FindPartsInRegion3WithIgnoreList(ignore, maxParts)
end
--
return RotatedRegion3
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="214">
            <Properties>
              <string name="Name">GJK</string>
              <string name="Source"><![CDATA[
local MAX_TRIES = 20
local ZERO3 = Vector3.new(0, 0, 0)
-- Class
local GJK = {}
GJK.__index = GJK
-- Private Functions
local function tripleProduct(a, b, c)
	return b * c:Dot(a) - a * c:Dot(b)
end
local function containsOrigin(self, simplex, direction)
	local a = simplex[#simplex]
	local ao = -a
	if (#simplex == 4) then
		local b, c, d = simplex[3], simplex[2], simplex[1]
		local ab, ac, ad = b - a, c - a, d - a
		local abc, acd, adb = ab:Cross(ac), ac:Cross(ad), ad:Cross(ab)
		
		abc = abc:Dot(ad) > 0 and -abc or abc
		acd = acd:Dot(ab) > 0 and -acd or acd
		adb = adb:Dot(ac) > 0 and -adb or adb
		
		if (abc:Dot(ao) > 0) then
			table.remove(simplex, 1)
			direction = abc
		elseif (acd:Dot(ao) > 0) then
			table.remove(simplex, 2)
			direction = acd
		elseif (adb:Dot(ao) > 0) then
			table.remove(simplex, 3)
			direction = adb
		else
			return true
		end
	elseif (#simplex == 3) then
		local b, c = simplex[2], simplex[1]
		local ab, ac = b - a, c - a
		
		local abc = ab:Cross(ac)
		local abPerp = tripleProduct(ac, ab, ab).Unit
		local acPerp = tripleProduct(ab, ac, ac).Unit
		
		if (abPerp:Dot(ao) > 0) then
			table.remove(simplex, 1)
			direction = abPerp
		elseif (acPerp:Dot(ao) > 0) then
			table.remove(simplex, 2)
			direction = acPerp
		else
			local isV3 = ((a - a) == ZERO3)
			if (not isV3) then
				return true
			else
				direction = abc:Dot(ao) > 0 and abc or -abc
			end
		end
	else
		local b = simplex[1]
		local ab = b - a
		local bcPerp = tripleProduct(ab, ao, ab).Unit
		direction = bcPerp
	end
	
	return false, direction
end
-- Public Constructors
function GJK.new(SetA, SetB, CentroidA, CentroidB, SupportA, SupportB)
	local self = setmetatable({}, GJK)
	
	self.SetA = SetA
	self.SetB = SetB
	self.CentroidA = CentroidA
	self.CentroidB = CentroidB
	self.SupportA = SupportA
	self.SupportB = SupportB
	return self
end
-- Public Methods
function GJK:IsColliding()
	local direction = (self.CentroidA - self.CentroidB).Unit
	local simplex = {self.SupportA(self.SetA, direction) - self.SupportB(self.SetB, -direction)}
	
	direction = -direction
	
	for i = 1, MAX_TRIES do
		table.insert(simplex, self.SupportA(self.SetA, direction) - self.SupportB(self.SetB, -direction))
		
		if (simplex[#simplex]:Dot(direction) <= 0) then
			return false
		else
			local passed, newDirection = containsOrigin(self, simplex, direction)
			
			if (passed) then
				return true
			end
			
			direction = newDirection
		end
	end
	
	return false
end
--
return GJK
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="215">
            <Properties>
              <string name="Name">Supports</string>
              <string name="Source"><![CDATA[
local ZERO = Vector3.new(0, 0, 0)
local RIGHT = Vector3.new(1, 0, 0)
--
local function rayPlane(p, v, s, n)
	local r = p - s;
	local t = -r:Dot(n) / v:Dot(n)
	return p + t * v, t
end;
--
local Supports = {}
function Supports.PointCloud(set, direction)
	local max, maxDot = set[1], set[1]:Dot(direction)
	for i = 2, #set do
		local dot = set[i]:Dot(direction)
		if (dot > maxDot) then
			max = set[i]
			maxDot = dot
		end
	end
	return max
end
function Supports.Cylinder(set, direction)
	local cf, size2 = unpack(set)
	direction = cf:VectorToObjectSpace(direction)
	local radius = math.min(size2.y, size2.z)
	local dotT, cPoint = direction:Dot(RIGHT), Vector3.new(size2.x, 0, 0)
	local h, t, final
	
	if (dotT == 0) then
		final = direction.Unit * radius
	else
		cPoint = dotT > 0 and cPoint or -cPoint
		h, t = rayPlane(ZERO, direction, cPoint, RIGHT)
		final = cPoint + (h - cPoint).Unit * radius
	end
	
	return cf:PointToWorldSpace(final)
end
function Supports.Ellipsoid(set, direction)
	local cf, size2 = unpack(set)
	return cf:PointToWorldSpace(size2 * (size2 * cf:VectorToObjectSpace(direction)).Unit)
end
return Supports
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="216">
            <Properties>
              <string name="Name">Vertices</string>
              <string name="Source"><![CDATA[
-- CONSTANTS
local PI2 = math.pi*2
local PHI = (1 + math.sqrt(5)) / 2
local RIGHT 	= Vector3.new(1, 0, 0)
local UP 		= Vector3.new(0, 1, 0)
local BACK 		= Vector3.new(0, 0, 1)
local LEFT 		= Vector3.new(-1, 0, 0)
local DOWN 		= Vector3.new(0, -1, 0)
local FORWARD 	= Vector3.new(0, 0, -1)
local CORNERS = {
	Vector3.new(1, 1, 1);
	Vector3.new(-1, 1, 1);
	Vector3.new(-1, 1, -1);
	Vector3.new(1, 1, -1);
	Vector3.new(1, -1, 1);
	Vector3.new(-1, -1, 1);
	Vector3.new(-1, -1, -1);
	Vector3.new(1, -1, -1);
}
-- VERTICE INDEX ARRAYS
local BLOCK = {1, 2, 3, 4, 5, 6, 7, 8}
local WEDGE = {1, 2, 5, 6, 7, 8}
local CORNERWEDGE = {4, 5, 6, 7, 8}
-- VERTICE FUNCTIONS
local function fromIndexArray(array)
	local output = {}
	for i = 1, #array do
		output[i] = CORNERS[array[i]]
	end
	return output
end
local function cylinder(n)
	local output = {}
	local arc = PI2 / n
	for i = 1, n do
		local vi = CFrame.fromAxisAngle(RIGHT, i*arc) * UP
		output[i] = RIGHT + vi
		output[n + i] = LEFT + vi
	end
	return output
end
local function icoSphere(n)
	local verts = {
		Vector3.new(-1,  PHI, 0),
		Vector3.new(1,  PHI, 0),
		Vector3.new(-1, -PHI, 0),
		Vector3.new(1, -PHI, 0),
		
		Vector3.new(0, -1,  PHI),
		Vector3.new(0,  1,  PHI),
		Vector3.new(0, -1, -PHI),
		Vector3.new(0,  1, -PHI),
		
		Vector3.new(PHI, 0, -1),
		Vector3.new(PHI, 0,  1),
		Vector3.new(-PHI, 0, -1),
		Vector3.new(-PHI, 0,  1)
	}
	
	local indices = {
		1, 12, 6,
		1, 6, 2,
		1, 2, 8,
		1, 8, 11,
		1, 11, 12,
		
		2, 6, 10,
		6, 12, 5,
		12, 11, 3,
		11, 8, 7,
		8, 2, 9,
		
		4, 10, 5,
		4, 5, 3,
		4, 3, 7,
		4, 7, 9,
		4, 9, 10,
		
		5, 10, 6,
		3, 5, 12,
		7, 3, 11,
		9, 7, 8,
		10, 9, 2
	}
	
	local splits = {}
	
	local function split(i, j)
		local key = i < j and (i .. "," .. j) or (j .. "," .. i)
		
		if (not splits[key]) then
			verts[#verts+1] = (verts[i] + verts[j]) / 2
			splits[key] = #verts
		end
		
		return splits[key]
	end
	
	for _ = 1, n do
		for  i = #indices, 1, -3 do
			local v1, v2, v3 = indices[i - 2], indices[i - 1], indices[i]
			local a = split(v1, v2)
			local b = split(v2, v3)
			local c = split(v3, v1)
			
			indices[#indices+1] = v1
			indices[#indices+1] = a
			indices[#indices+1] = c
			
			indices[#indices+1] = v2
			indices[#indices+1] = b
			indices[#indices+1] = a
			
			indices[#indices+1] = v3
			indices[#indices+1] = c
			indices[#indices+1] = b
			
			indices[#indices+1] = a
			indices[#indices+1] = b
			indices[#indices+1] = c
			
			table.remove(indices, i)
			table.remove(indices, i - 1)
			table.remove(indices, i - 2)
		end
	end
	
	-- normalize
	for i = 1, #verts do
		verts[i] = verts[i].Unit
	end
	
	return verts
end
-- Useful functions
local function vertShape(cf, size2, array)
	local output = {}
	for i = 1, #array do
		output[i] = cf:PointToWorldSpace(array[i] * size2)
	end
	return output
end
local function getCentroidFromSet(set)
	local sum = set[1]
	for i = 2, #set do
		sum = sum + set[2]
	end
	return sum / #set
end
local function classify(part)
	if (part.ClassName == "Part") then
		if (part.Shape == Enum.PartType.Block) then
			return "Block"
		elseif (part.Shape == Enum.PartType.Cylinder) then
			return "Cylinder"
		elseif (part.Shape == Enum.PartType.Ball) then
			return "Ball"
		end;
	elseif (part.ClassName == "WedgePart") then
		return "Wedge"
	elseif (part.ClassName == "CornerWedgePart") then
		return "CornerWedge"
	elseif (part:IsA("BasePart")) then -- mesh, CSG, truss, etc... just use block
		return "Block"
	end
end
-- 
local BLOCK_ARRAY = fromIndexArray(BLOCK)
local WEDGE_ARRAY = fromIndexArray(WEDGE)
local CORNERWEDGE_ARRAY = fromIndexArray(CORNERWEDGE)
local CYLINDER_ARRAY = cylinder(20)
local SPHERE_ARRAY = icoSphere(2)
return {
	Block = function(cf, size2) return vertShape(cf, size2, BLOCK_ARRAY) end;
	Wedge = function(cf, size2) return vertShape(cf, size2, WEDGE_ARRAY) end;
	CornerWedge = function(cf, size2) return vertShape(cf, size2, CORNERWEDGE_ARRAY) end;
	Cylinder = function(cf, size2) return vertShape(cf, size2, CYLINDER_ARRAY) end;
	Ball = function(cf, size2) return vertShape(cf, size2, SPHERE_ARRAY) end;
	
	GetCentroid = getCentroidFromSet;
	Classify = classify;
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="217">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/rotatedregion3",
	_id = "@rbxts/rotatedregion3@1.2.0",
	_inBundle = false,
	_integrity = "sha512-G0ilVuLBk/262WqTJBsHfWtP/A6YBN53TfsbrHxS4MQcNCAitj8Vl0537N7TtyMQdghypGnubh2IWPlRXXKFLw==",
	_location = "/@rbxts/rotatedregion3",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2frotatedregion3",
		fetchSpec = "latest",
		name = "@rbxts/rotatedregion3",
		raw = "@rbxts/rotatedregion3",
		rawSpec = "",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "tag",
	},
	_requiredBy = {"#USER", "/"},
	_resolved = "https://registry.npmjs.org/@rbxts/rotatedregion3/-/rotatedregion3-1.2.0.tgz",
	_shasum = "46ca9df3a5274ba55ec442378a92b75bb7c008d5",
	_spec = "@rbxts/rotatedregion3",
	_where = "C:\\Users\\jhein\\Documents\\Github\\Mojave",
	author = {
		name = "OverHash",
	},
	bugs = {
		url = "https://github.com/OverHash/Roblox-TS-Libraries/issues",
	},
	bundleDependencies = false,
	deprecated = false,
	description = "A port of EgoMoose's Rotated Region 3 module.",
	homepage = "https://github.com/OverHash/Roblox-TS-Libraries/blob/master/RotatedRegion3/README.md",
	keywords = {"RotatedRegion3", "roblox", "roblox-typescript", "roblox-ts"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/rotatedregion3",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/OverHash/Roblox-TS-Libraries/tree/master/RotatedRegion3",
	},
	scripts = {
		test = "echo \"Error: no test specified\" &amp;&amp; exit 1",
	},
	types = "index.d.ts",
	version = "1.2.0",
}</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="218">
          <Properties>
            <string name="Name">services</string>
            <string name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="219">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/services",
	_id = "@rbxts/services@1.1.5",
	_inBundle = false,
	_integrity = "sha512-5/SGYCVcdvxIM19ZFf4k9Hq5jCNLW0c/1G804yr9+KuPteVyfag4YiBgkXE3QmGx1ITixIQJJYIKv1LoueWPww==",
	_location = "/@rbxts/services",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2fservices",
		fetchSpec = "latest",
		name = "@rbxts/services",
		raw = "@rbxts/services",
		rawSpec = "",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "tag",
	},
	_requiredBy = {"#USER", "/"},
	_resolved = "https://registry.npmjs.org/@rbxts/services/-/services-1.1.5.tgz",
	_shasum = "cde5d38a60f38bdf3acfc4263d702f16a238dae6",
	_spec = "@rbxts/services",
	_where = "C:\\Users\\jhein\\Documents\\Github\\Mojave",
	author = "",
	bundleDependencies = false,
	deprecated = false,
	description = "A module that exports common Roblox services.",
	devDependencies = {
		["@rbxts/types"] = "^1.0.491",
	},
	files = {"init.lua", "index.d.ts"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/services",
	scripts = {
	},
	typings = "index.d.ts",
	version = "1.1.5",
}</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="220">
          <Properties>
            <string name="Name">t</string>
          </Properties>
          <Item class="Folder" referent="221">
            <Properties>
              <string name="Name">lib</string>
            </Properties>
            <Item class="ModuleScript" referent="222">
              <Properties>
                <string name="Name">ts</string>
                <string name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

-- regular lua compatibility
local typeof = typeof or type

local function primitive(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

local t = {}

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = primitive("boolean")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = primitive("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = primitive("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = primitive("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = primitive("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = primitive("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = primitive("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	if value ~= value then
		return true
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = primitive("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = primitive("BrickColor")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = primitive("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = primitive("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = primitive("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = primitive("ColorSequenceKeypoint")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = primitive("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = primitive("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = primitive("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = primitive("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = primitive("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = primitive("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = primitive("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = primitive("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = primitive("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = primitive("Ray")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = primitive("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = primitive("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = primitive("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = primitive("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = primitive("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = primitive("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = primitive("Vector2")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = primitive("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = primitive("Vector3int16")

-- roblox enum types

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = primitive("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = primitive("EnumItem")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = primitive("RBXScriptSignal")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = primitive("RBXScriptConnection")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The functon to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="223">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/t",
	_id = "@rbxts/t@2.1.4",
	_inBundle = false,
	_integrity = "sha512-DjDoh3NkcM3fmJDjwrcJaSKJu6oykUvJnZK2voRgZLlfb/8Nk4MNAlYLsuBiSexJA/q89+kOa8YzS/WN7Ysdow==",
	_location = "/@rbxts/t",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2ft",
		fetchSpec = "latest",
		name = "@rbxts/t",
		raw = "@rbxts/t",
		rawSpec = "",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "tag",
	},
	_requiredBy = {"#USER", "/"},
	_resolved = "https://registry.npmjs.org/@rbxts/t/-/t-2.1.4.tgz",
	_shasum = "fd9f7a6caff44b06258f6bdc7705bb75833b7953",
	_spec = "@rbxts/t",
	_where = "C:\\Users\\jhein\\Documents\\Github\\Mojave",
	author = {
		name = "osyris",
	},
	bugs = {
		url = "https://github.com/osyrisrblx/t/issues",
	},
	bundleDependencies = false,
	deprecated = false,
	description = "A Runtime Type Checker for Roblox",
	devDependencies = {
		["@rbxts/types"] = "^1.0.469",
	},
	files = {"lib/ts.lua", "lib/t.d.ts"},
	homepage = "https://github.com/osyrisrblx/t#readme",
	keywords = {},
	license = "ISC",
	main = "lib/ts.lua",
	name = "@rbxts/t",
	repository = {
		type = "git",
		url = "git+https://github.com/osyrisrblx/t.git",
	},
	types = "lib/t.d.ts",
	version = "2.1.4",
}</string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="224">
          <Properties>
            <string name="Name">types</string>
          </Properties>
          <Item class="Folder" referent="225">
            <Properties>
              <string name="Name">include</string>
            </Properties>
            <Item class="Folder" referent="226">
              <Properties>
                <string name="Name">generated</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="227">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	author = "roblox-ts",
	bugs = {
		url = "https://github.com/roblox-ts/types/issues",
	},
	dependencies = {
	},
	description = "TypeScript typings for the Roblox platform. Partially handwritten and partially automatically generated.",
	homepage = "https://github.com/roblox-ts/types#readme",
	keywords = {"types", "Roblox", "typescript"},
	license = "MIT",
	main = "include/roblox.d.ts",
	name = "@rbxts/types",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-ts/types.git",
	},
	scripts = {
	},
	types = "include/roblox.d.ts",
	version = "1.0.503",
}</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="228">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="229">
      <Properties>
        <string name="Name">Server</string>
      </Properties>
      <Item class="Script" referent="230">
        <Properties>
          <string name="Name">age_script</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
Players.PlayerAdded:Connect(function(player)
	if player.AccountAge < 7 then
		player:Kick("Your account must be at least a week old in order to play!")
	end
end)
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="231">
        <Properties>
          <string name="Name">faction_handler</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _faction_manager = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "faction_manager")
local quitCaching = _faction_manager.quitCaching
local startCaching = _faction_manager.startCaching
startCaching()
game:BindToClose(function()
	return quitCaching()
end)
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="232">
        <Properties>
          <string name="Name">generate_factions</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local ReplicatedStorage = TS.import(script, TS.getModule(script, "@rbxts", "services")).ReplicatedStorage
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local Allies = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "allies").default
local location = ReplicatedStorage:FindFirstChild("FamilyList")
local _arg0 = t.instanceOf("Folder")(location)
assert(_arg0, "Expected folder in ReplicatedStorage named 'FamilyList'")
local function generateFactionFolder(group)
	local folder = Instance.new("Folder")
	folder.Name = group.Name
	local idValue = Instance.new("NumberValue")
	idValue.Name = "GroupID"
	idValue.Value = group.Id
	idValue.Parent = folder
	local decal = Instance.new("Decal")
	decal.Name = "Flag"
	decal.Texture = group.EmblemUrl
	decal.Parent = folder
	return folder
end
local function generate()
	local _result = location
	if _result ~= nil then
		_result:ClearAllChildren()
	end
	for _, group in ipairs(Allies:getAllies()) do
		generateFactionFolder(group).Parent = location
	end
end
local _bindable = script.Parent
if _bindable ~= nil then
	_bindable = _bindable:FindFirstChild("onjoin")
	if _bindable ~= nil then
		_bindable = _bindable:FindFirstChild("reloadteams")
	end
end
local bindable = _bindable
if t.instanceIsA("BindableEvent")(bindable) then
	bindable.Event:Connect(generate)
end
generate()
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="233">
        <Properties>
          <string name="Name">onjoin</string>
          <string name="Source">-- THIS SCRIPT WAS CREATED WITH ROJO; ANY CHANGES MADE IN STUDIO WILL BE OVERWRITTEN

local Players = game:GetService("Players")
local autoteam = require(script.autoteam)
local nametag = require(script.nametag)

function init()
    autoteam.removeTeams()
    autoteam.generateTeams()
    for _, player in pairs(Players:GetPlayers()) do
        onJoin(player)
    end
end

function onJoin(player)
    autoteam.assignTeam(player)
    nametag(player)
end

Players.PlayerAdded:Connect(onJoin)

script.reloadteams.Event:Connect(init)

init()</string>
        </Properties>
        <Item class="ModuleScript" referent="234">
          <Properties>
            <string name="Name">autoteam</string>
            <string name="Source">-- THIS SCRIPT WAS CREATED WITH ROJO; ANY CHANGES MADE IN STUDIO WILL BE OVERWRITTEN

local Teams = game:GetService("Teams")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local teams = {}
local wastelanders
local Allies = require(ReplicatedStorage.Shared.allies).default
local usedColors
local current = 0
local customColorPattern = "Color: '([%a ]+)'"

function generateTeams()
    usedColors = {}

    wastelanders = Instance.new("Team")
    wastelanders.Name = "Wastelanders"
    wastelanders.TeamColor = BrickColor.Gray()
    wastelanders.Parent = Teams
    usedColors[BrickColor.Gray().Number] = true
    
    for _, group in pairs(Allies:getAllies()) do
        local customColor = string.match(group.Description, customColorPattern)
        local color
        if customColor and not usedColors[BrickColor.new(customColor).Number] then
            color = BrickColor.new(customColor)
        elseif customColor and tonumber(customColor) and not usedColors[BrickColor.new(tonumber(customColor)).Number] then
            color = BrickColor.new(tonumber(customColor))
        else
            while current &lt; 1032 do
                current += 1
                color = BrickColor.new(current)
                if not usedColors[color.Number] then
                    usedColors[color.Number] = true
                    break
                end
            end
        end
        assert(current &lt; 1032, "Out of colors")

        local team = Instance.new("Team")
        team.Name = group.Name
        team.TeamColor = color
        team.Parent = Teams
        teams[group.Id] = team
    end
end

function removeTeams()
    Teams:ClearAllChildren()
end

function assignTeam(player)
    for id, team in pairs(teams) do
        if player:IsInGroup(id) then
            player.Team = team
            return
        end
    end
    player.Team = wastelanders
end

return { assignTeam = assignTeam, removeTeams = removeTeams, generateTeams = generateTeams }</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="235">
          <Properties>
            <string name="Name">nametag</string>
            <string name="Source">-- THIS SCRIPT WAS CREATED WITH ROJO; ANY CHANGES MADE IN STUDIO WILL BE OVERWRITTEN

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact: Roact = TS.import(script, TS.getModule(script, "roact").src)
local Allies = require(ReplicatedStorage.Shared.allies).default
local mainGroup = 4978642

function nametag(props)
    return Roact.createElement("BillboardGui",
        {
            Size = UDim2.fromScale(4, 1.5),
            StudsOffset = Vector3.new(0, 3.5, 0),
            MaxDistance = 150,
            LightInfluence = 0,
            Enabled = props.visible
        },
        {
            Roact.createElement("TextLabel",
                {
                    Position = UDim2.new(0, 5, 0, 0),
                    Size = UDim2.new(1, -10, 0.5, 0),
                    ZIndex = 2,
                    BackgroundTransparency = 1,
                    TextColor3 = props.color,
                    Font = Enum.Font.SourceSansBold,
                    TextScaled = true,
                    Text = props.name
                }
            ),
            Roact.createElement("TextLabel",
                {
                    Position = UDim2.new(0, 5, 0.5, 0),
                    Size = UDim2.new(1, -10, 0.25, 0),
                    BackgroundTransparency = 1,
                    TextColor3 = props.color,
                    Font = Enum.Font.SourceSansBold,
                    TextScaled = true,
                    Text = props.team
                }
            ),
            Roact.createElement("TextLabel",
                {
                    Position = UDim2.new(0, 5, 0.75, 0),
                    Size = UDim2.new(1, -10, 0.25, 0),
                    BackgroundTransparency = 1,
                    TextColor3 = props.color,
                    Font = Enum.Font.SourceSansBold,
                    TextScaled = true,
                    Text = props.rank
                }
            )
        }
    )
end

function onCharacter(player, character)
    local team = player.Team
    assert(team, "No team assigned!")
    local group
    for _, ally in pairs(Allies:getAllies()) do
        if team.Name == ally.Name then
            group = ally
        end
    end
    local rank
    if player:GetRankInGroup(mainGroup) >= 20 or not group then
        rank = player:GetRoleInGroup(mainGroup)
    else
        rank = player:GetRoleInGroup(group.Id)
    end
    local nametagProps = {
        name = player.DisplayName,
        team = team.Name,
        rank = rank,
        color = team.TeamColor.Color,
        visible = true
    }
    local existingNametag = character.HumanoidRootPart:FindFirstChild("RoactTree");
    if existingNametag then
        existingNametag:Destroy()
    end
    local nametagHandle = Roact.mount(nametag(nametagProps), character.HumanoidRootPart)
    character.Humanoid.Animator.AnimationPlayed:Connect(function(animation: AnimationTrack)
        if tostring(animation.Animation.AnimationId) == "rbxassetid://6911830449" and nametagProps.visible then
            nametagProps.visible = false
            Roact.update(nametagHandle, nametag(nametagProps))
        elseif not nametagProps.visible then
            nametagProps.visible = true
            Roact.update(nametagHandle, nametag(nametagProps))
        end
    end)
    character.Humanoid.NameDisplayDistance = 0
    local connection
    connection = player.CharacterRemoving:Connect(function()
        Roact.unmount(nametagHandle);
        connection:Disconnect()
    end)
end

function addNametag(player: Player)
    if player.Character and player.Character:FindFirstChild("Head") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid:FindFirstChild("Animator") then
        onCharacter(player, player.Character)
    end
    player.CharacterAdded:Connect(function(character)
        onCharacter(player, character)
    end)
end

return addNametag</string>
          </Properties>
        </Item>
        <Item class="BindableEvent" referent="236">
          <Properties>
            <string name="Name">reloadteams</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Script" referent="237">
        <Properties>
          <string name="Name">point_handler</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local ReplicatedStorage = _services.ReplicatedStorage
local Workspace = _services.Workspace
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local _condition = Workspace:FindFirstChild("Points")
if _condition == nil then
	_condition = ReplicatedStorage:FindFirstChild("Points")
end
local location = _condition
local _arg0 = t.instanceOf("Folder")(location)
assert(_arg0, "Expected folder in the Workspace or ReplicatedStorage named 'Points'")
location.Parent = ReplicatedStorage
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="238">
        <Properties>
          <string name="Name">safezones</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local Workspace = _services.Workspace
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local _region = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "region")
local BasePartRegion = _region.BasePartRegion
local RegionUnion = _region.RegionUnion
local Remotes = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "remotes").default
local inSafezone = Remotes.Server:Create("InSafezone")
local validSafezoneChildren = t.array(t.instanceIsA("BasePart"))
local _condition = Workspace:FindFirstChild("Safezones")
if _condition == nil then
	_condition = ReplicatedStorage:FindFirstChild("Safezones")
end
local safezoneFolder = _condition
assert(safezoneFolder, "Expected a folder named 'Safezones' in the workspace or ReplicatedStorage")
local safezoneParts = safezoneFolder:GetChildren()
local _arg0 = validSafezoneChildren(safezoneParts)
assert(_arg0, "Expected children of 'Safezones' folder to be BaseParts")
local _arg0_1 = function(safezonePart)
	return BasePartRegion.new(safezonePart)
end
-- ▼ ReadonlyArray.map ▼
local _newValue = table.create(#safezoneParts)
for _k, _v in ipairs(safezoneParts) do
	_newValue[_k] = _arg0_1(_v, _k - 1, safezoneParts)
end
-- ▲ ReadonlyArray.map ▲
local safezoneRegions = RegionUnion.new(_newValue)
local shielded = setmetatable({}, {
	__mode = "k",
})
safezoneFolder.Parent = ReplicatedStorage
local function safezoneCheck(player, character)
	if character == nil then
		character = player.Character
	end
	local _result = character
	if _result ~= nil then
		_result = _result.PrimaryPart
	end
	local _condition_1 = _result
	if _condition_1 then
		_condition_1 = safezoneRegions:isInRegion(character.PrimaryPart)
	end
	if _condition_1 then
		local forceField = Instance.new("ForceField")
		forceField.Visible = false
		forceField.Name = "Safezone"
		forceField.Parent = character
		-- ▼ Map.set ▼
		shielded[character] = forceField
		-- ▲ Map.set ▲
		inSafezone:SendToPlayer(player, true)
		local _exp = safezoneRegions:leftRegion(character.PrimaryPart)
		local _arg0_2 = function()
			forceField:Destroy()
			inSafezone:SendToPlayer(player, false)
		end
		_exp:andThen(_arg0_2)
	else
		inSafezone:SendToPlayer(player, false)
	end
end
inSafezone:Connect(function(player, _)
	return safezoneCheck(player)
end)
local onCharacter = function(player, character)
	RunService.Heartbeat:Wait()
	safezoneCheck(player, character)
end
local onPlayer = function(player)
	player.CharacterAdded:Connect(function(character)
		return onCharacter(player, character)
	end)
end
local _exp = Players:GetPlayers()
-- ▼ ReadonlyArray.forEach ▼
for _k, _v in ipairs(_exp) do
	onPlayer(_v, _k - 1, _exp)
end
-- ▲ ReadonlyArray.forEach ▲
Players.PlayerAdded:Connect(onPlayer)
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="239">
        <Properties>
          <string name="Name">selling</string>
          <string name="Source">-- THIS SCRIPT WAS CREATED WITH ROJO; ANY CHANGES MADE IN STUDIO WILL BE OVERWRITTEN

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        if ReplicatedStorage:FindFirstChild("ESell") then
            local gui = ReplicatedStorage.ESell:Clone()
            gui.Parent = player.Character:WaitForChild("HumanoidRootPart")
        else
            warn("ESell not found in ReplicatedStorage- selling may not function properly.")
        end
    end)
end)</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="240">
      <Properties>
        <string name="Name">Vendor</string>
      </Properties>
    </Item>
  </Item>
  <Item class="SoundService" referent="241">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="242">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="243">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="244">
        <Properties>
          <string name="Name">Client</string>
        </Properties>
        <Item class="ModuleScript" referent="245">
          <Properties>
            <string name="Name">client_points_handler</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local ReplicatedStorage = TS.import(script, TS.getModule(script, "@rbxts", "services")).ReplicatedStorage
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local GameMap = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "map").GameMap
local _point_gen = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "map", "point_gen")
local genPoints = _point_gen.genPoints
local mapBounds = _point_gen.mapBounds
local location = ReplicatedStorage:WaitForChild("Points", 5)
local _arg0 = t.instanceOf("Folder")(location)
assert(_arg0, "Expected folder in the ReplicatedStorage named 'Points'")
local points = genPoints(location:GetChildren())
local bounds = mapBounds(points)
local gameMap = GameMap.new(points, bounds)
local default = gameMap
return {
	default = default,
}
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="246">
          <Properties>
            <string name="Name">gui_handler</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local StarterGui = TS.import(script, TS.getModule(script, "@rbxts", "services")).StarterGui
local SpawnGui = TS.import(script, script.Parent, "spawn_gui").SpawnGui
local HUD = TS.import(script, script.Parent, "hud").HUD
TS.try(function()
	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
	SpawnGui:mount()
	SpawnGui.finished:Wait()
	SpawnGui:unmount()
end, function(error)
	warn("Unable to load SpawnGui! Error: " .. tostring(error))
end)
StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, false)
HUD:mount()
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="247">
          <Properties>
            <string name="Name">hud</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local HudComponent = TS.import(script, script, "components", "hud_component").HudComponent
local HUD
do
	HUD = setmetatable({}, {
		__tostring = function()
			return "HUD"
		end,
	})
	HUD.__index = HUD
	function HUD.new(...)
		local self = setmetatable({}, HUD)
		return self:constructor(...) or self
	end
	function HUD:constructor()
	end
	function HUD:mount()
		HUD.hudListener = Roact.mount(Roact.createElement(HudComponent), Players.LocalPlayer:FindFirstChildOfClass("PlayerGui"))
	end
	function HUD:unmount()
		if HUD.hudListener then
			Roact.unmount(HUD.hudListener)
		end
	end
end
return {
	HUD = HUD,
}
]]></string>
          </Properties>
          <Item class="Folder" referent="248">
            <Properties>
              <string name="Name">components</string>
            </Properties>
            <Item class="ModuleScript" referent="249">
              <Properties>
                <string name="Name">ap</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local ActionPoints
do
	ActionPoints = Roact.Component:extend("ActionPoints")
	function ActionPoints:init()
	end
	function ActionPoints:render()
		return Roact.createFragment({
			ActionPoints = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				Position = UDim2.new(1, -240, 1, -46),
				Size = UDim2.new(0, 235, 0, 40),
			}, {
				Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Font = Enum.Font.ArialBold,
					Position = UDim2.new(1, -35, 0, 0),
					Size = UDim2.new(0, 35, 0, 40),
					Text = "AP",
					TextColor3 = Color3.fromRGB(255, 170, 0),
					TextSize = 24,
					ZIndex = 2,
				}, {
					Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.ArialBold,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(0, 35, 0, 40),
						Text = "AP",
						TextColor3 = Color3.fromRGB(67, 67, 67),
						TextSize = 24,
					}, {
						Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.ArialBold,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(0, 35, 0, 40),
							Text = "AP",
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextSize = 24,
						}),
					}),
				}),
				Bars = Roact.createElement("Frame", {
					BackgroundTransparency = 1,
					Position = UDim2.new(0, 0, 0, 10),
					Size = UDim2.new(0, 200, 0, 10),
				}, {
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Position = UDim2.new(0, 0, 1, -2),
						Size = UDim2.new(1, 0, 0, 2),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					ActionBar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Size = UDim2.new(1, 0, 1, 0),
						ZIndex = 3,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Position = UDim2.new(1, -2, 0, 0),
						Size = UDim2.new(0, 2, 1, 0),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Size = UDim2.new(0, 2, 1, 0),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
				}),
			}),
		})
	end
end
return {
	ActionPoints = ActionPoints,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="250">
              <Properties>
                <string name="Name">caps</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local Caps
do
	Caps = Roact.Component:extend("Caps")
	function Caps:init(props)
		local _result = Players.LocalPlayer:FindFirstChild("Data")
		if _result ~= nil then
			_result = _result:FindFirstChild("Caps")
		end
		local _condition = _result
		if _condition == nil then
			local _result_1 = Players.LocalPlayer:WaitForChild("Data", 5)
			if _result_1 ~= nil then
				_result_1 = _result_1:WaitForChild("Caps", 5)
			end
			_condition = _result_1
		end
		self.capsValue = _condition
		self.state = {
			caps = "N/A",
		}
		local capsValue = self.capsValue
		if t.instanceIsA("IntValue")(capsValue) then
			capsValue.Changed:Connect(function(caps)
				return self:setState({
					caps = tostring(caps),
				})
			end)
			self:setState({
				caps = tostring(capsValue.Value),
			})
		end
	end
	function Caps:render()
		return Roact.createFragment({
			Caps = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
			}, {
				CapsIcon = Roact.createElement("ImageLabel", {
					AnchorPoint = Vector2.new(0.5, 0),
					BackgroundTransparency = 1,
					Image = "rbxassetid://73202079",
					ImageColor3 = Color3.fromRGB(255, 170, 0),
					Position = UDim2.new(0, 13, 1, -130),
					Size = UDim2.new(0, 25, 0, 25),
					ZIndex = 2,
				}, {
					Shadow = Roact.createElement("ImageLabel", {
						BackgroundTransparency = 1,
						Image = "rbxassetid://1117379455",
						ImageColor3 = Color3.fromRGB(0, 0, 0),
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
					}),
					Caps = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.ArialBold,
						Position = UDim2.new(1, 5, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						Text = self.state.caps,
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextSize = 20,
						TextXAlignment = Enum.TextXAlignment.Left,
						ZIndex = 2,
					}, {
						Caps = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.ArialBold,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							Text = self.state.caps,
							TextColor3 = Color3.new(0, 0, 0),
							TextSize = 20,
							TextXAlignment = Enum.TextXAlignment.Left,
						}),
					}),
				}),
			}),
		})
	end
end
return {
	Caps = Caps,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="251">
              <Properties>
                <string name="Name">compass</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Compass
do
	Compass = Roact.Component:extend("Compass")
	function Compass:init()
	end
	function Compass:render()
		return Roact.createFragment({
			Compass = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				ClipsDescendants = true,
				Position = UDim2.new(0.5, -135, 1, -54),
				Size = UDim2.new(0, 270, 0, 50),
			}, {
				Bars = Roact.createElement("Frame", {
					BackgroundTransparency = 1,
					Position = UDim2.new(0, 0, 0, 20),
					Size = UDim2.new(1, 0, 0, 12),
				}, {
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Position = UDim2.new(1, -2, 0, 0),
						Size = UDim2.new(0, 2, 1, 0),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Position = UDim2.new(0, 0, 1, -2),
						Size = UDim2.new(1, 0, 0, 2),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Size = UDim2.new(0, 2, 1, 0),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					Roact.createElement("ImageLabel", {
						BackgroundTransparency = 1,
						Image = "rbxassetid://99753110",
						ImageColor3 = Color3.fromRGB(255, 170, 0),
						ImageTransparency = 0.7,
						Position = UDim2.new(0, 0, 0, -14),
						Rotation = 180,
						Size = UDim2.new(1, 0, 0, 24),
					}),
				}),
				Compass = Roact.createElement("Frame", {
					BackgroundTransparency = 1,
					ClipsDescendants = true,
					Position = UDim2.new(0, 0, 0, 32),
					Size = UDim2.new(1, 0, 0, 20),
				}, {
					N = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.Arial,
						Size = UDim2.new(1, 0, 1, 0),
						Text = "N",
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextScaled = true,
						TextSize = 24,
						TextTransparency = 0.2,
						TextWrapped = true,
						ZIndex = 2,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.Arial,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							Text = "N",
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextScaled = true,
							TextSize = 24,
							TextWrapped = true,
						}, {
							Shadow = Roact.createElement("TextLabel", {
								BackgroundTransparency = 1,
								Font = Enum.Font.Arial,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								Text = "N",
								TextColor3 = Color3.fromRGB(67, 67, 67),
								TextScaled = true,
								TextSize = 24,
								TextWrapped = true,
							}),
						}),
					}),
					W = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.Arial,
						Position = UDim2.new(-1, 0, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						Text = "W",
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextScaled = true,
						TextSize = 24,
						TextTransparency = 0.2,
						TextWrapped = true,
						ZIndex = 2,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.Arial,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							Text = "W",
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextScaled = true,
							TextSize = 24,
							TextWrapped = true,
						}, {
							Shadow = Roact.createElement("TextLabel", {
								BackgroundTransparency = 1,
								Font = Enum.Font.Arial,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								Text = "W",
								TextColor3 = Color3.fromRGB(67, 67, 67),
								TextScaled = true,
								TextSize = 24,
								TextWrapped = true,
							}),
						}),
					}),
					S = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.Arial,
						Position = UDim2.new(2, 0, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						Text = "S",
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextScaled = true,
						TextSize = 24,
						TextTransparency = 0.2,
						TextWrapped = true,
						ZIndex = 2,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.Arial,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							Text = "S",
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextScaled = true,
							TextSize = 24,
							TextWrapped = true,
						}, {
							Shadow = Roact.createElement("TextLabel", {
								BackgroundTransparency = 1,
								Font = Enum.Font.Arial,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								Text = "S",
								TextColor3 = Color3.fromRGB(67, 67, 67),
								TextScaled = true,
								TextSize = 24,
								TextWrapped = true,
							}),
						}),
					}),
					E = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.Arial,
						Position = UDim2.new(1, 0, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						Text = "E",
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextScaled = true,
						TextSize = 24,
						TextTransparency = 0.2,
						TextWrapped = true,
						ZIndex = 2,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.Arial,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							Text = "E",
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextScaled = true,
							TextSize = 24,
							TextWrapped = true,
						}, {
							Shadow = Roact.createElement("TextLabel", {
								BackgroundTransparency = 1,
								Font = Enum.Font.Arial,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								Text = "E",
								TextColor3 = Color3.fromRGB(67, 67, 67),
								TextScaled = true,
								TextSize = 24,
								TextWrapped = true,
							}),
						}),
					}),
					SE = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.Arial,
						Position = UDim2.new(1.5, 0, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						Text = "SE",
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextScaled = true,
						TextSize = 24,
						TextTransparency = 0.2,
						TextWrapped = true,
						Visible = false,
						ZIndex = 2,
					}),
					NE = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.Arial,
						Position = UDim2.new(0.5, 0, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						Text = "NE",
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextScaled = true,
						TextSize = 24,
						TextTransparency = 0.2,
						TextWrapped = true,
						Visible = false,
						ZIndex = 2,
					}),
					SW = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.Arial,
						Position = UDim2.new(-1.5, 0, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						Text = "SW",
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextScaled = true,
						TextSize = 24,
						TextTransparency = 0.2,
						TextWrapped = true,
						Visible = false,
						ZIndex = 2,
					}),
					NW = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.Arial,
						Position = UDim2.new(-0.5, 0, 0, 0),
						Size = UDim2.new(1, 0, 1, 0),
						Text = "NW",
						TextColor3 = Color3.fromRGB(255, 170, 0),
						TextScaled = true,
						TextSize = 24,
						TextTransparency = 0.2,
						TextWrapped = true,
						Visible = false,
						ZIndex = 2,
					}),
				}),
				Tickmark = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(255, 63, 29),
					Position = UDim2.new(0, 10, 0, 18),
					Size = UDim2.new(0, 10, 0, 10),
					Visible = false,
					ZIndex = 3,
				}, {
					Shadow = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(67, 67, 67),
						BorderSizePixel = 0,
						Position = UDim2.new(0, 2, 0, 2),
						Size = UDim2.new(1, 0, 1, 0),
						ZIndex = 2,
					}),
				}),
			}),
		})
	end
end
return {
	Compass = Compass,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="252">
              <Properties>
                <string name="Name">health</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local Username = TS.import(script, script.Parent, "username").Username
local Health
do
	Health = Roact.Component:extend("Health")
	function Health:init(props)
		self.state = {
			health = 0,
		}
		Players.LocalPlayer.CharacterAdded:Connect(function(character)
			return self:onCharacter(character)
		end)
		local existingCharacter = Players.LocalPlayer.Character
		if existingCharacter then
			self:onCharacter(existingCharacter)
		end
	end
	function Health:onCharacter(character)
		local _condition = character:FindFirstChildOfClass("Humanoid")
		if _condition == nil then
			_condition = character:WaitForChild("Humanoid", 5)
		end
		local humanoid = _condition
		if t.instanceOf("Humanoid")(humanoid) then
			humanoid:GetPropertyChangedSignal("Health"):Connect(function()
				return self:setState({
					health = humanoid.Health,
				})
			end)
			self:setState({
				health = humanoid.Health,
			})
		end
	end
	function Health:render()
		return Roact.createFragment({
			Health = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				Position = UDim2.new(0, 4, 1, -46),
				Size = UDim2.new(0.2, 0, 0, 40),
			}, {
				Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Font = Enum.Font.ArialBold,
					Size = UDim2.new(0, 35, 0, 40),
					Text = "HP",
					TextColor3 = Color3.fromRGB(255, 170, 0),
					TextSize = 24,
					ZIndex = 2,
				}, {
					Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.ArialBold,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(0, 35, 0, 40),
						Text = "HP",
						TextColor3 = Color3.fromRGB(67, 67, 67),
						TextSize = 24,
					}, {
						Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.ArialBold,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(0, 35, 0, 40),
							Text = "HP",
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextSize = 24,
						}),
					}),
				}),
				Bars = Roact.createElement("Frame", {
					BackgroundTransparency = 1,
					Position = UDim2.new(0, 35, 0, 10),
					Size = UDim2.new(1, -35, 0, 10),
				}, {
					RightBar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Position = UDim2.new(1, -2, 0, 0),
						Size = UDim2.new(0, 2, 1, 0),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					LeftBar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Size = UDim2.new(0, 2, 1, 0),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					BottomBar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Size = UDim2.new(1, 0, 0, 2),
						Position = UDim2.new(0, 0, 1, 0),
						ZIndex = 3,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					HealthBar = Roact.createElement("Frame", {
						BackgroundColor3 = self.state.health > 100 and Color3.new(0, 0.35, 1) or Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Size = UDim2.new(math.clamp(self.state.health / 100, 0, 1), -math.clamp(self.state.health / 100 * 4, 0, 4), 1, 0),
						Position = UDim2.new(0, 2, 0, 0),
						ZIndex = 3,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
					RadsBar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 91, 58),
						BorderSizePixel = 0,
						Position = UDim2.new(0.9, 0, 0, 0),
						Size = UDim2.new(0.1, 0, 1, 0),
						Visible = false,
						ZIndex = 3,
					}),
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(255, 170, 0),
						BorderSizePixel = 0,
						Position = UDim2.new(1, -2, 0, 0),
						Size = UDim2.new(0, 2, 1, 0),
						ZIndex = 4,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}, {
							Bar = Roact.createElement("Frame", {
								BackgroundColor3 = Color3.fromRGB(67, 67, 67),
								BorderSizePixel = 0,
								Position = UDim2.new(0, 1, 0, 1),
								Size = UDim2.new(1, 0, 1, 0),
								ZIndex = 2,
							}),
						}),
					}),
				}),
				RadsAmount = Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Font = Enum.Font.ArialBold,
					Position = UDim2.new(1, -110, 0, -26),
					Size = UDim2.new(0, 100, 0, 40),
					Text = "+1 RADS",
					TextColor3 = Color3.fromRGB(255, 0, 0),
					TextSize = 24,
					TextXAlignment = Enum.TextXAlignment.Right,
					Visible = false,
					ZIndex = 2,
				}, {
					Shadow = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.ArialBold,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(0, 100, 0, 40),
						Text = "+1 RADS",
						TextColor3 = Color3.fromRGB(67, 67, 67),
						TextSize = 24,
						TextXAlignment = Enum.TextXAlignment.Right,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.ArialBold,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(0, 100, 0, 40),
							Text = "+1 RADS",
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextSize = 24,
							TextXAlignment = Enum.TextXAlignment.Right,
						}),
					}),
				}),
				RadIcon = Roact.createElement("ImageLabel", {
					BackgroundTransparency = 1,
					Image = "rbxassetid://339643706",
					ImageColor3 = Color3.fromRGB(255, 50, 23),
					Position = UDim2.new(1, 0, 0, -20),
					Size = UDim2.new(0, 40, 0, 40),
					Visible = false,
					ZIndex = 2,
				}, {
					Shadow = Roact.createElement("ImageLabel", {
						BackgroundTransparency = 1,
						Image = "rbxassetid://339643706",
						ImageColor3 = Color3.fromRGB(67, 67, 67),
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(0, 40, 0, 40),
					}, {
						Shadow = Roact.createElement("ImageLabel", {
							BackgroundTransparency = 1,
							Image = "rbxassetid://339643706",
							ImageColor3 = Color3.fromRGB(67, 67, 67),
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(0, 40, 0, 40),
						}),
					}),
				}),
				Roact.createElement(Username),
			}),
		})
	end
end
return {
	Health = Health,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="253">
              <Properties>
                <string name="Name">hud_component</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Caps = TS.import(script, script.Parent, "caps").Caps
local Health = TS.import(script, script.Parent, "health").Health
local Scope = TS.import(script, script.Parent, "scope").Scope
local Settings = TS.import(script, script.Parent, "settings").Settings
local State = TS.import(script, script.Parent, "state").State
local ToolComponent = TS.import(script, script.Parent, "tool").ToolComponent
local HudComponent
do
	HudComponent = Roact.Component:extend("HudComponent")
	function HudComponent:init()
	end
	function HudComponent:render()
		return Roact.createFragment({
			HUD = Roact.createElement("ScreenGui", {
				ResetOnSpawn = false,
			}, {
				Roact.createElement(Health),
				Roact.createElement(ToolComponent),
				Roact.createElement(State),
				Roact.createElement(Scope),
				Roact.createElement(Settings),
				Roact.createElement(Caps),
			}),
		})
	end
end
return {
	HudComponent = HudComponent,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="254">
              <Properties>
                <string name="Name">scope</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Scope
do
	Scope = Roact.Component:extend("Scope")
	function Scope:init()
	end
	function Scope:render()
		return Roact.createFragment({
			ScopeOverlay = Roact.createElement("ImageLabel", {
				BackgroundTransparency = 1,
				Image = "rbxassetid://358324484",
				ImageColor3 = Color3.fromRGB(0, 0, 0),
				Position = UDim2.new(0.5, -200, 0.5, -200),
				Size = UDim2.new(0, 400, 0, 400),
				Visible = false,
				ZIndex = 10,
			}, {
				Frame4 = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(0, 0, 0),
					BorderSizePixel = 0,
					Position = UDim2.new(0.5, -1500, 1, 0),
					Size = UDim2.new(0, 3000, 0, 600),
					ZIndex = 10,
				}),
				Frame3 = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(0, 0, 0),
					BorderSizePixel = 0,
					Position = UDim2.new(0.5, -1500, 0, -600),
					Size = UDim2.new(0, 3000, 0, 600),
					ZIndex = 10,
				}),
				Frame1 = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(0, 0, 0),
					BorderSizePixel = 0,
					Position = UDim2.new(1, 0, 0.5, -1500),
					Size = UDim2.new(0, 600, 0, 3000),
					ZIndex = 10,
				}),
				Frame2 = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(0, 0, 0),
					BorderSizePixel = 0,
					Position = UDim2.new(0, -600, 0.5, -1500),
					Size = UDim2.new(0, 600, 0, 3000),
					ZIndex = 10,
				}),
			}),
		})
	end
end
return {
	Scope = Scope,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="255">
              <Properties>
                <string name="Name">settings</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local Settings
do
	Settings = Roact.Component:extend("Settings")
	function Settings:init(props)
	end
	function Settings:render()
		return Roact.createFragment({
			Settings = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
			}, {
				Left = Roact.createElement("ImageButton", {
					Active = false,
					BackgroundTransparency = 1,
					Image = "http://www.roblox.com/asset/?id=4677859281",
					ImageColor3 = Color3.fromRGB(255, 170, 0),
					Position = UDim2.new(0, 0, 1, -100),
					Size = UDim2.new(0, 30, 0, 30),
					Selectable = false,
					ZIndex = 2,
					[Roact.Event.MouseButton1Click] = function()
						local _result = Players.LocalPlayer:FindFirstChild("PlayerGui")
						if _result ~= nil then
							_result = _result:FindFirstChild("Settings")
						end
						local _condition = _result
						if _condition == nil then
							local _result_1 = Players.LocalPlayer:WaitForChild("PlayerGui", 5)
							if _result_1 ~= nil then
								_result_1 = _result_1:WaitForChild("Settings", 5)
							end
							_condition = _result_1
						end
						local settings = _condition
						local _result_1 = settings
						if _result_1 ~= nil then
							_result_1 = _result_1:IsA("ScreenGui")
						end
						if _result_1 then
							settings.Enabled = not settings.Enabled
						else
							error("Settings not found!")
						end
					end,
				}, {
					Shadow = Roact.createElement("ImageButton", {
						Active = false,
						BackgroundTransparency = 1,
						Image = "http://www.roblox.com/asset/?id=4677859281",
						ImageColor3 = Color3.new(0, 0, 0),
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
						Selectable = false,
					}),
				}),
			}),
		})
	end
end
return {
	Settings = Settings,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="256">
              <Properties>
                <string name="Name">state</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Remotes = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "remotes").default
local State
do
	State = Roact.Component:extend("State")
	function State:init(props)
		self.state = {
			safe = false,
		}
		Remotes.Client:Get("InSafezone"):Connect(function(safe)
			return self:setState({
				safe = safe,
			})
		end)
	end
	function State:render()
		return Roact.createFragment({
			Safezone = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				ClipsDescendants = true,
				Position = UDim2.new(0, 4, 0, 4),
				Size = UDim2.new(0, 230, 0, 35),
				Visible = self.state.safe,
			}, {
				Bottom_Bars = Roact.createElement("Frame", {
					BackgroundTransparency = 1,
					Position = UDim2.new(0, 0, 1, -12),
					Size = UDim2.new(1, 0, 0, 12),
				}),
				Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Font = Enum.Font.ArialBold,
					Position = UDim2.new(0, 5, 0, 5),
					Size = UDim2.new(0, 220, 0, 25),
					Text = "YOU ARE IN A SAFE ZONE.",
					TextColor3 = Color3.fromRGB(255, 170, 0),
					TextScaled = true,
					TextSize = 18,
					TextWrapped = true,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					ZIndex = 2,
				}, {
					Shadow = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.ArialBold,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
						Text = "YOU ARE IN A SAFE ZONE.",
						TextColor3 = Color3.fromRGB(67, 67, 67),
						TextScaled = true,
						TextSize = 18,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Top,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.ArialBold,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							Text = "YOU ARE IN A SAFE ZONE.",
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextScaled = true,
							TextSize = 18,
							TextWrapped = true,
							TextXAlignment = Enum.TextXAlignment.Left,
							TextYAlignment = Enum.TextYAlignment.Top,
						}),
					}),
				}),
				Top_Left = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(255, 170, 0),
					BorderSizePixel = 0,
					Size = UDim2.new(0, 2, 1, 0),
					ZIndex = 4,
				}, {
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(67, 67, 67),
						BorderSizePixel = 0,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
						ZIndex = 2,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}),
					}),
				}),
				Top = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(255, 170, 0),
					BorderSizePixel = 0,
					Size = UDim2.new(1, 0, 0, 2),
					ZIndex = 4,
				}, {
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(67, 67, 67),
						BorderSizePixel = 0,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
						ZIndex = 2,
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							ZIndex = 2,
						}),
					}),
				}),
			}),
		})
	end
end
return {
	State = State,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="257">
              <Properties>
                <string name="Name">tool</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local ToolComponent
do
	ToolComponent = Roact.Component:extend("ToolComponent")
	function ToolComponent:init(props)
		self.state = {
			toolEquipped = false,
			toolName = "",
			hasGun = false,
			ammo = "",
			maxAmmo = "",
		}
		Players.LocalPlayer.CharacterAdded:Connect(function(character)
			return self:onCharacter(character)
		end)
		if Players.LocalPlayer.Character then
			self:onCharacter(Players.LocalPlayer.Character)
		end
	end
	function ToolComponent:onCharacter(character)
		character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self:onToolChange(character, child)
			end
		end)
		local existingTool = character:FindFirstChildOfClass("Tool")
		if existingTool then
			self:onToolChange(character, existingTool)
		end
	end
	function ToolComponent:onToolChange(character, tool)
		local ammoConnection
		if tool:FindFirstChild("BlasterSettings") then
			local ammo = tool:FindFirstChild("Ammo")
			local _maxAmmo = tool:FindFirstChild("BlasterSettings")
			if _maxAmmo ~= nil then
				_maxAmmo = _maxAmmo:FindFirstChild("Stats")
				if _maxAmmo ~= nil then
					_maxAmmo = _maxAmmo:FindFirstChild("MaxAmmo")
				end
			end
			local maxAmmo = _maxAmmo
			ammoConnection = t.instanceOf("IntValue")(ammo) and ammo.Changed:Connect(function(num)
				return self:setState({
					ammo = tostring(num),
				})
			end) or nil
			self:setState({
				toolEquipped = true,
				toolName = tool.Name,
				hasGun = true,
				ammo = t.instanceOf("IntValue")(ammo) and tostring(ammo.Value) or "N/A",
				maxAmmo = t.instanceOf("IntValue")(maxAmmo) and tostring(maxAmmo.Value) or "N/A",
			})
		else
			self:setState({
				toolEquipped = true,
				toolName = tool.Name,
				hasGun = false,
			})
		end
		tool.AncestryChanged:Connect(function()
			if tool.Parent ~= character then
				self:setState({
					toolEquipped = false,
				})
				local newTool = character:FindFirstChildOfClass("Tool")
				if newTool then
					self:onToolChange(character, newTool)
				end
				if ammoConnection then
					ammoConnection:Disconnect()
				end
			end
		end)
	end
	function ToolComponent:render()
		return Roact.createFragment({
			Ammo = Roact.createElement("Frame", {
				BackgroundTransparency = 1,
				Position = UDim2.new(1, -106, 1, -136),
				Size = UDim2.new(0, 100, 0, 80),
				Visible = self.state.toolEquipped,
			}, {
				MagAmmo = Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 0, 40),
					Text = self.state.ammo,
					TextColor3 = Color3.fromRGB(255, 170, 0),
					TextSize = 24,
					ZIndex = 2,
					Visible = self.state.hasGun,
				}, {
					Shadow = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 0, 40),
						Text = self.state.ammo,
						TextColor3 = Color3.fromRGB(67, 67, 67),
						TextSize = 24,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 0, 40),
							Text = self.state.ammo,
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextSize = 24,
						}),
					}),
				}),
				TotalAmmo = Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Position = UDim2.new(0, 0, 0, 40),
					Size = UDim2.new(1, 0, 0, 40),
					Text = self.state.maxAmmo,
					TextColor3 = Color3.fromRGB(255, 170, 0),
					TextSize = 24,
					ZIndex = 2,
					Visible = self.state.hasGun,
				}, {
					Shadow = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 0, 40),
						Text = self.state.maxAmmo,
						TextColor3 = Color3.fromRGB(67, 67, 67),
						TextSize = 24,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 0, 40),
							Text = self.state.maxAmmo,
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextSize = 24,
						}),
					}),
				}),
				Bar = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(255, 170, 0),
					BorderSizePixel = 0,
					Position = UDim2.new(0.5, -34, 0.5, -1),
					Size = UDim2.new(0, 70, 0, 2),
					ZIndex = 3,
					Visible = self.state.hasGun,
				}, {
					Bar = Roact.createElement("Frame", {
						BackgroundColor3 = Color3.fromRGB(67, 67, 67),
						BorderSizePixel = 0,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
					}, {
						Bar = Roact.createElement("Frame", {
							BackgroundColor3 = Color3.fromRGB(67, 67, 67),
							BorderSizePixel = 0,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
						}),
					}),
				}),
				ToolName = Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Font = Enum.Font.ArialBold,
					Position = UDim2.new(0, -10, 1, 0),
					Size = UDim2.new(0, 100, 0, 10),
					Text = self.state.toolName,
					TextColor3 = Color3.fromRGB(255, 170, 0),
					TextSize = 18,
					TextXAlignment = Enum.TextXAlignment.Right,
					ZIndex = 2,
				}, {
					Shadow = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.ArialBold,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
						Text = self.state.toolName,
						TextColor3 = Color3.fromRGB(67, 67, 67),
						TextSize = 18,
						TextXAlignment = Enum.TextXAlignment.Right,
					}, {
						Shadow = Roact.createElement("TextLabel", {
							BackgroundTransparency = 1,
							Font = Enum.Font.ArialBold,
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
							Text = self.state.toolName,
							TextColor3 = Color3.fromRGB(67, 67, 67),
							TextSize = 18,
							TextXAlignment = Enum.TextXAlignment.Right,
						}),
					}),
				}),
				FiringModeIcon = Roact.createElement("ImageLabel", {
					BackgroundTransparency = 1,
					Image = "rbxassetid://358920621",
					ImageColor3 = Color3.fromRGB(255, 170, 0),
					ImageRectOffset = Vector2.new(0, 156),
					ImageRectSize = Vector2.new(144, 156),
					Position = UDim2.new(0, -10, 0.5, -10),
					Size = UDim2.new(0, 20, 0, 20),
					ZIndex = 2,
					Visible = self.state.hasGun,
				}, {
					Shadow = Roact.createElement("ImageLabel", {
						BackgroundTransparency = 1,
						Image = "rbxassetid://358920621",
						ImageColor3 = Color3.fromRGB(67, 67, 67),
						ImageRectOffset = Vector2.new(0, 156),
						ImageRectSize = Vector2.new(144, 156),
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
					}, {
						Shadow = Roact.createElement("ImageLabel", {
							BackgroundTransparency = 1,
							Image = "rbxassetid://358920621",
							ImageColor3 = Color3.fromRGB(67, 67, 67),
							ImageRectOffset = Vector2.new(0, 156),
							ImageRectSize = Vector2.new(144, 156),
							Position = UDim2.new(0, 1, 0, 1),
							Size = UDim2.new(1, 0, 1, 0),
						}),
					}),
				}),
			}),
		})
	end
end
return {
	ToolComponent = ToolComponent,
}
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="258">
              <Properties>
                <string name="Name">username</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local Username
do
	Username = Roact.Component:extend("Username")
	function Username:init(props)
		self.state = {
			displayName = Players.LocalPlayer.DisplayName,
		}
		Players.LocalPlayer:GetPropertyChangedSignal("DisplayName"):Connect(function()
			return self:setState({
				displayName = Players.LocalPlayer.DisplayName,
			})
		end)
	end
	function Username:render()
		local displayName = self.state.displayName
		return Roact.createFragment({
			Username = Roact.createElement("TextLabel", {
				BackgroundTransparency = 1,
				ClipsDescendants = true,
				Font = Enum.Font.SourceSansBold,
				Position = UDim2.new(0, 0, 0, -14),
				Size = UDim2.new(0, 140, 0, 20),
				Text = displayName,
				TextColor3 = Color3.fromRGB(255, 170, 0),
				TextScaled = true,
				TextSize = 14,
				TextWrapped = true,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Bottom,
				ZIndex = 2,
			}, {
				Shadow = Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Font = Enum.Font.SourceSansBold,
					Position = UDim2.new(0, 1, 0, 1),
					Size = UDim2.new(1, 0, 1, 0),
					Text = displayName,
					TextColor3 = Color3.fromRGB(67, 67, 67),
					TextScaled = true,
					TextSize = 14,
					TextWrapped = true,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Bottom,
				}, {
					Shadow = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.SourceSansBold,
						Position = UDim2.new(0, 1, 0, 1),
						Size = UDim2.new(1, 0, 1, 0),
						Text = displayName,
						TextColor3 = Color3.fromRGB(67, 67, 67),
						TextScaled = true,
						TextSize = 14,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Bottom,
					}),
				}),
			}),
		})
	end
end
return {
	Username = Username,
}
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="LocalScript" referent="259">
          <Properties>
            <string name="Name">safezones</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local ReplicatedStorage = _services.ReplicatedStorage
local Workspace = _services.Workspace
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local _region = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "region")
local BasePartRegion = _region.BasePartRegion
local RegionUnion = _region.RegionUnion
local Remotes = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "remotes").default
local inSafezone = Remotes.Client:Get("InSafezone")
local validSafezoneChildren = t.array(t.instanceIsA("BasePart"))
local _condition = Workspace:FindFirstChild("Safezones")
if _condition == nil then
	_condition = ReplicatedStorage:FindFirstChild("Safezones")
end
local safezoneFolder = _condition
assert(safezoneFolder, "Expected a folder named 'Safezones' in the workspace or ReplicatedStorage")
local safezoneParts = safezoneFolder:GetChildren()
local _arg0 = validSafezoneChildren(safezoneParts)
assert(_arg0, "Expected children of 'Safezones' folder to be BaseParts")
local _arg0_1 = function(safezonePart)
	return BasePartRegion.new(safezonePart)
end
-- ▼ ReadonlyArray.map ▼
local _newValue = table.create(#safezoneParts)
for _k, _v in ipairs(safezoneParts) do
	_newValue[_k] = _arg0_1(_v, _k - 1, safezoneParts)
end
-- ▲ ReadonlyArray.map ▲
local safezoneRegions = RegionUnion.new(_newValue)
local shielded = false
local function enteredRegion(part)
	if not shielded then
		shielded = true
		wait()
		inSafezone:SendToServer(true)
	end
end
local function onCharacter(character)
	local part = character:WaitForChild("HumanoidRootPart")
	if t.instanceIsA("Part")(part) then
		local promise = safezoneRegions:enteredRegion(part)
		local _arg0_2 = function()
			return enteredRegion(part)
		end
		promise:andThen(_arg0_2)
		Players.LocalPlayer.CharacterRemoving:Connect(function()
			return promise:cancel()
		end)
	end
end
inSafezone:Connect(function(isInSafezone)
	if isInSafezone then
		shielded = true
	else
		shielded = false
		local _root = Players.LocalPlayer.Character
		if _root ~= nil then
			_root = _root:WaitForChild("HumanoidRootPart", 5)
		end
		local root = _root
		if t.instanceIsA("Part")(root) and safezoneRegions:isInRegion(root) then
			wait(0.5)
			shielded = true
			inSafezone:SendToServer(true)
		elseif t.instanceIsA("Part")(root) then
			local promise = safezoneRegions:enteredRegion(root)
			local _arg0_2 = function()
				return enteredRegion(root)
			end
			promise:andThen(_arg0_2)
			Players.LocalPlayer.CharacterRemoving:Connect(function()
				return promise:cancel()
			end)
		end
	end
end)
if Players.LocalPlayer.Character then
	onCharacter(Players.LocalPlayer.Character)
end
Players.LocalPlayer.CharacterAdded:Connect(onCharacter)
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="260">
          <Properties>
            <string name="Name">spawn_gui</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local ObjectEvent = TS.import(script, TS.getModule(script, "@rbxts", "object-event"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local SpawnGuiComponent = TS.import(script, script, "components", "spawn_gui").SpawnGuiComponent
local SpawnGui
do
	SpawnGui = setmetatable({}, {
		__tostring = function()
			return "SpawnGui"
		end,
	})
	SpawnGui.__index = SpawnGui
	function SpawnGui.new(...)
		local self = setmetatable({}, SpawnGui)
		return self:constructor(...) or self
	end
	function SpawnGui:constructor()
	end
	function SpawnGui:mount()
		local screenBinding = { Roact.createBinding(0) }
		SpawnGui.spawnGuiListener = Roact.mount(Roact.createElement(SpawnGuiComponent, {
			currentScreen = screenBinding,
			finished = self.finished,
		}), Players.LocalPlayer:FindFirstChildOfClass("PlayerGui"))
	end
	function SpawnGui:unmount()
		if SpawnGui.spawnGuiListener then
			Roact.unmount(SpawnGui.spawnGuiListener)
		end
	end
	SpawnGui.finished = ObjectEvent.new()
end
return {
	SpawnGui = SpawnGui,
}
]]></string>
          </Properties>
          <Item class="Folder" referent="261">
            <Properties>
              <string name="Name">components</string>
            </Properties>
            <Item class="ModuleScript" referent="262">
              <Properties>
                <string name="Name">progress</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local MapScreen = TS.import(script, script.Parent, "screens", "map").MapScreen
local TeamsScreen = TS.import(script, script.Parent, "screens", "teams").TeamsScreen
local ProgressComponent
do
	ProgressComponent = Roact.Component:extend("ProgressComponent")
	function ProgressComponent:init(props)
		local valueChange = props.currentScreen[2]
		props.currentScreen[2] = function(newValue)
			valueChange(newValue)
			self:setState({})
		end
		self.screens = { TeamsScreen.new(0, props.currentScreen), MapScreen.new(1, props.currentScreen, self.props.finished) }
	end
	function ProgressComponent:render()
		local items = { Roact.createElement("UIListLayout", {
			FillDirection = Enum.FillDirection.Horizontal,
			HorizontalAlignment = Enum.HorizontalAlignment.Center,
			Padding = UDim.new(0.1, 0),
			SortOrder = Enum.SortOrder.LayoutOrder,
		}) }
		local _screens = self.screens
		local _arg0 = function(screen)
			local _arg0_1 = screen:getButtonComponent()
			-- ▼ Array.push ▼
			local _length = #items
			items[_length + 1] = _arg0_1
			-- ▲ Array.push ▲
			return _length + 1
		end
		-- ▼ ReadonlyArray.forEach ▼
		for _k, _v in ipairs(_screens) do
			_arg0(_v, _k - 1, _screens)
		end
		-- ▲ ReadonlyArray.forEach ▲
		return Roact.createElement("Frame", {
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
		}, {
			Roact.createElement("Frame", {
				Name = "List",
				BackgroundTransparency = 1,
				Position = UDim2.new(0.3, 70, 0, 0),
				Size = UDim2.new(0.7, -70, 0, 36),
			}, items),
			self.screens[self.props.currentScreen[1]:getValue() + 1]:getScreenComponent(),
		})
	end
end
return {
	ProgressComponent = ProgressComponent,
}
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="263">
              <Properties>
                <string name="Name">screens</string>
              </Properties>
              <Item class="ModuleScript" referent="264">
                <Properties>
                  <string name="Name">map</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local gameMap = TS.import(script, script.Parent.Parent.Parent.Parent, "client_points_handler").default
local Screen = TS.import(script, script.Parent, "screen").Screen
local MapPointComponent = TS.import(script, script, "map_point").MapPointComponent
local MapComponent
do
	MapComponent = Roact.Component:extend("MapComponent")
	function MapComponent:init(props)
		self.tooltipVisible = { Roact.createBinding(false) }
		self.tooltipText = { Roact.createBinding("") }
		local _points = gameMap.points
		local _arg0 = function(point)
			return Roact.createElement(MapPointComponent, {
				point = point,
				size = gameMap.size,
			})
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_points)
		for _k, _v in ipairs(_points) do
			_newValue[_k] = _arg0(_v, _k - 1, _points)
		end
		-- ▲ ReadonlyArray.map ▲
		self.mapPoints = _newValue
	end
	function MapComponent:render()
		local _ptr = {
			BackgroundColor3 = Color3.fromRGB(46, 46, 46),
			BorderSizePixel = 0,
			Position = UDim2.new(0, 0, 0, 36),
			Size = UDim2.new(1, 0, 1, -36),
		}
		local _ptr_1 = {}
		local _length = #_ptr_1
		local _ptr_2 = {
			BackgroundTransparency = 1,
			Position = UDim2.new(0.1, 0, 0.1, 0),
			Size = UDim2.new(0.8, -30, 0.8, -30),
			BorderSizePixel = 0,
		}
		local _ptr_3 = {}
		local _length_1 = #_ptr_3
		for _k, _v in ipairs(self.mapPoints) do
			_ptr_3[_length_1 + _k] = _v
		end
		_ptr_1.MapFrame = Roact.createElement("Frame", _ptr_2, _ptr_3)
		return Roact.createFragment({
			Map = Roact.createElement("Frame", _ptr, _ptr_1),
		})
	end
end
local MapScreen
do
	local super = Screen
	MapScreen = setmetatable({}, {
		__tostring = function()
			return "MapScreen"
		end,
		__index = super,
	})
	MapScreen.__index = MapScreen
	function MapScreen.new(...)
		local self = setmetatable({}, MapScreen)
		return self:constructor(...) or self
	end
	function MapScreen:constructor(position, currentScreen, finished)
		super.constructor(self, position, currentScreen)
		self.position = position
		self.currentScreen = currentScreen
		self.finished = finished
		self.name = "Spawn"
	end
	function MapScreen:getScreenComponent()
		return Roact.createElement(MapComponent, {
			finished = self.finished,
		})
	end
end
return {
	MapScreen = MapScreen,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="265">
                  <Properties>
                    <string name="Name">map_point</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local MapPointComponent
do
	MapPointComponent = Roact.Component:extend("MapPointComponent")
	function MapPointComponent:init(props)
		print(props.point.position, props.size)
		local relPosition = Vector2.new(props.point.position.X / props.size.X, props.point.position.Y / props.size.Y)
		self.position = UDim2.fromScale(relPosition.X, relPosition.Y)
	end
	function MapPointComponent:render()
		local borderColor = self.props.point.safezone and Color3.fromRGB(92, 168, 255) or Color3.fromRGB(255, 226, 86)
		return Roact.createFragment({
			Destination = Roact.createElement("TextButton", {
				BackgroundColor3 = self.props.controlling and self.props.controlling:map(function(faction)
					return faction.color.Color
				end) or Color3.new(0.5, 0.5, 0.5),
				BorderColor3 = borderColor,
				BorderSizePixel = 5,
				BorderMode = Enum.BorderMode.Inset,
				Font = Enum.Font.SourceSans,
				Position = self.position,
				Size = UDim2.new(0, 30, 0, 30),
				Text = "",
				TextColor3 = Color3.fromRGB(0, 0, 0),
				TextSize = 14,
				AutoButtonColor = false,
			}, {
				Title = Roact.createElement("TextLabel", {
					Position = UDim2.new(0.5, -20, -1, 0),
					Size = UDim2.new(0, 40, 1, 0),
					BackgroundTransparency = 1,
					TextSize = 15,
					TextColor3 = Color3.fromRGB(0, 0, 0),
					TextStrokeColor3 = borderColor,
					TextStrokeTransparency = 0,
					TextYAlignment = Enum.TextYAlignment.Top,
					TextXAlignment = Enum.TextXAlignment.Center,
					Font = Enum.Font.SourceSansBold,
					Text = self.props.point.name,
				}),
			}),
		})
	end
end
return {
	MapPointComponent = MapPointComponent,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="266">
                  <Properties>
                    <string name="Name">tooltip</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local TooltipComponent
do
	TooltipComponent = Roact.Component:extend("TooltipComponent")
	function TooltipComponent:init()
	end
	function TooltipComponent:render()
		return Roact.createFragment({
			Tooltip = Roact.createElement("Frame", {
				BackgroundColor3 = Color3.fromRGB(126, 111, 42),
				BorderColor3 = Color3.fromRGB(255, 226, 86),
				BorderSizePixel = 3,
				Position = self.props.position:map(function(position)
					return UDim2.fromScale(position.X, position.Y)
				end),
				Size = UDim2.new(0, 283, 0, 60),
				Visible = self.props.visible,
			}, {
				DestinationInfo = Roact.createElement("TextLabel", {
					BackgroundTransparency = 1,
					Font = Enum.Font.SourceSansSemibold,
					Position = UDim2.new(0, 5, 0, 0),
					Size = UDim2.new(1, -10, 1, 0),
					Text = self.props.text,
					TextColor3 = Color3.fromRGB(255, 226, 86),
					TextSize = 32,
					TextXAlignment = Enum.TextXAlignment.Left,
				}),
				Tooltip = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(126, 111, 42),
					BorderColor3 = Color3.fromRGB(255, 226, 86),
					BorderSizePixel = 3,
					Position = UDim2.new(0, 0, 1, 3),
					Size = UDim2.new(0, 283, 0, 32),
				}, {
					SpawnButton = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.SourceSansBold,
						Position = UDim2.new(0, 5, 0, 0),
						Size = UDim2.new(1, -10, 1, 0),
						Text = "SPAWN",
						TextColor3 = Color3.fromRGB(255, 226, 86),
						TextSize = 32,
						Visible = self.props.canSpawn,
					}),
				}),
			}),
		})
	end
end
return {
	TooltipComponent = TooltipComponent,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="267">
                <Properties>
                  <string name="Name">progress_item</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local ProgressItemComponent
do
	ProgressItemComponent = Roact.Component:extend("ProgressItemComponent")
	function ProgressItemComponent:init(props)
		self.state = {
			selected = props.startSelected,
		}
	end
	function ProgressItemComponent:render()
		return Roact.createFragment({
			[tostring(self.props.name)] = Roact.createElement("TextButton", {
				BackgroundTransparency = 1,
				Font = Enum.Font.SourceSansBold,
				LayoutOrder = self.props.position,
				Position = UDim2.new(0, 70, 0, 0),
				Size = UDim2.new(0.2, 0, 0, 36),
				Text = tostring(self.props.name),
				TextColor3 = self.props.selected:map(function(currentScreen)
					return currentScreen == self.props.position and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(172, 172, 172)
				end),
				TextScaled = true,
				TextSize = 24,
				TextWrapped = true,
				[Roact.Event.MouseButton1Click] = function()
					return self.props.updateSelection(self.props.position)
				end,
			}),
		})
	end
end
return {
	ProgressItemComponent = ProgressItemComponent,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="268">
                <Properties>
                  <string name="Name">screen</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local ObjectEvent = TS.import(script, TS.getModule(script, "@rbxts", "object-event"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local ProgressItemComponent = TS.import(script, script.Parent, "progress_item").ProgressItemComponent
local Screen
do
	Screen = {}
	function Screen:constructor(position, currentScreen)
		self.position = position
		self.currentScreen = currentScreen
		self.finished = ObjectEvent.new()
		self.deselected = ObjectEvent.new()
		self.selected = ObjectEvent.new()
		self.startSelected = position == 0
	end
	function Screen:getButtonComponent()
		return Roact.createElement(ProgressItemComponent, {
			name = self.name,
			position = self.position,
			startSelected = self.startSelected,
			deselectEvent = self.deselected,
			selected = self.currentScreen[1],
			updateSelection = self.currentScreen[2],
		})
	end
end
return {
	Screen = Screen,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="269">
                <Properties>
                  <string name="Name">teams</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local ObjectEvent = TS.import(script, TS.getModule(script, "@rbxts", "object-event"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local Workspace = _services.Workspace
local getClientFactionInfo = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "faction_manager").getClientFactionInfo
local Screen = TS.import(script, script.Parent, "screen").Screen
local AvatarViewportComponent = TS.import(script, script, "avatar_viewport").AvatarViewportComponent
local TeamButtonComponent = TS.import(script, script, "teambutton").TeamButtonComponent
-- const buttons = new Array<Roact.Element>();
-- for (let i = 0; i < 3; i++)
-- buttons.push(<TeamButtonComponent
-- Name={tostring(i)}
-- Avatar={<AvatarViewportComponent />}
-- StartSize={0.3}
-- SelectedEvent={new ObjectEvent<[number]>()}
-- DeselectedEvent={new ObjectEvent<[number]>()}
-- />)
local TeamsComponent
do
	TeamsComponent = Roact.Component:extend("TeamsComponent")
	function TeamsComponent:init(props)
		self.event = ObjectEvent.new()
		self.teamSelectedEvent = ObjectEvent.new()
		local _exp = getClientFactionInfo()
		local _arg0 = function(factionInfo)
			self:setState({
				factions = factionInfo,
			})
			self.teamSelectedEvent:Connect(function(id)
				local _result
				if id == -1 then
					_result = "Wastelanders"
				else
					local _arg0_1 = function(faction)
						return faction.groupId == id
					end
					-- ▼ ReadonlyArray.find ▼
					local _result_1 = nil
					for _i, _v in ipairs(factionInfo) do
						if _arg0_1(_v, _i - 1, factionInfo) == true then
							_result_1 = _v
							break
						end
					end
					-- ▲ ReadonlyArray.find ▲
					local _result_2 = _result_1
					if _result_2 ~= nil then
						_result_2 = _result_2.name
					end
					_result = _result_2
				end
				print("The client has selected to spawn as the " .. tostring(_result) .. " (id:" .. tostring(id) .. ")")
				self.props.currentScreen[2](self.props.currentScreen[1]:getValue() + 1)
			end)
		end
		_exp:andThen(_arg0)
		local _result = Workspace.CurrentCamera
		if _result ~= nil then
			_result = _result:GetPropertyChangedSignal("ViewportSize"):Connect(function()
				return self:render()
			end)
		end
	end
	function TeamsComponent:render()
		local teams = {}
		local _result = self.state.factions
		if _result ~= nil then
			_result = #_result
		end
		local _condition = _result
		if _condition == nil then
			_condition = 0
		end
		local numFactions = _condition + 1
		local _result_1 = self.state.factions
		if _result_1 ~= nil then
			local _arg0 = function(faction)
				local _arg0_1 = Roact.createElement(TeamButtonComponent, {
					Name = faction.shortName,
					Id = faction.groupId,
					Avatar = Roact.createElement(AvatarViewportComponent, {
						player = Players.LocalPlayer,
						shirtId = faction.uniformTop,
						pantsId = faction.uniformBottom,
					}),
					NumButtons = numFactions,
					StartSelectedIfAlone = false,
					SelectedEvent = self.event,
					SelectionFinishedEvent = self.teamSelectedEvent,
				})
				-- ▼ Array.push ▼
				local _length = #teams
				teams[_length + 1] = _arg0_1
				-- ▲ Array.push ▲
				return _length + 1
			end
			-- ▼ ReadonlyArray.forEach ▼
			for _k, _v in ipairs(_result_1) do
				_arg0(_v, _k - 1, _result_1)
			end
			-- ▲ ReadonlyArray.forEach ▲
		end
		local _ptr = {
			BackgroundColor3 = Color3.fromRGB(255, 255, 255),
			BorderSizePixel = 0,
			Position = UDim2.new(0, 0, 0, 36),
			Size = UDim2.new(1, 0, 1, -36),
		}
		local _ptr_1 = {
			Roact.createElement("UIListLayout", {
				FillDirection = Enum.FillDirection.Horizontal,
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),
			Roact.createElement(TeamButtonComponent, {
				Name = "WASTELANDER",
				Id = -1,
				Avatar = Roact.createElement(AvatarViewportComponent, {
					player = Players.LocalPlayer,
					shirtId = 333020740,
					pantsId = 333020646,
				}),
				NumButtons = numFactions,
				StartSelectedIfAlone = true,
				SelectedEvent = self.event,
				SelectionFinishedEvent = self.teamSelectedEvent,
			}),
		}
		local _length = #_ptr_1
		for _k, _v in ipairs(teams) do
			_ptr_1[_length + _k] = _v
		end
		return Roact.createFragment({
			Teams = Roact.createElement("Frame", _ptr, _ptr_1),
		})
	end
end
local TeamsScreen
do
	local super = Screen
	TeamsScreen = setmetatable({}, {
		__tostring = function()
			return "TeamsScreen"
		end,
		__index = super,
	})
	TeamsScreen.__index = TeamsScreen
	function TeamsScreen.new(...)
		local self = setmetatable({}, TeamsScreen)
		return self:constructor(...) or self
	end
	function TeamsScreen:constructor(...)
		super.constructor(self, ...)
		self.name = "Teams"
	end
	function TeamsScreen:getScreenComponent()
		return Roact.createElement(TeamsComponent, {
			currentScreen = self.currentScreen,
		})
	end
end
return {
	TeamsScreen = TeamsScreen,
}
]]></string>
                </Properties>
                <Item class="ModuleScript" referent="270">
                  <Properties>
                    <string name="Name">avatar_viewport</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Avatar = TS.import(script, game:GetService("ReplicatedStorage"), "Shared", "avatar").Avatar
local AvatarViewportComponent
do
	AvatarViewportComponent = Roact.Component:extend("AvatarViewportComponent")
	function AvatarViewportComponent:init(props)
		self.viewportRef = Roact.createRef()
		self.avatarGenerator = Avatar.new(props.player)
	end
	AvatarViewportComponent.didMount = TS.async(function(self)
		local viewport = self.viewportRef:getValue()
		if viewport then
			local camera = Instance.new("Camera")
			camera.CFrame = CFrame.lookAt(Vector3.new(0, 0, -5), Vector3.new(0, 0, 0))
			camera.CameraType = Enum.CameraType.Scriptable
			camera.FieldOfView = 70
			local character = self.avatarGenerator:loadCharacter()
			local _value = self.props.shirtId
			if _value ~= 0 and _value == _value and _value then
				self.avatarGenerator:changeShirt(character, self.props.shirtId)
			end
			local _value_1 = self.props.pantsId
			if _value_1 ~= 0 and _value_1 == _value_1 and _value_1 then
				self.avatarGenerator:changePants(character, self.props.pantsId)
			end
			camera.Parent = viewport
			viewport.CurrentCamera = camera
			character.Parent = viewport
		end
	end)
	function AvatarViewportComponent:render()
		return Roact.createFragment({
			Avatar = Roact.createElement("ViewportFrame", {
				Ambient = Color3.fromRGB(106, 106, 106),
				BackgroundTransparency = 1,
				LightColor = Color3.fromRGB(255, 255, 255),
				LightDirection = Vector3.new(2, -1, -1),
				Size = UDim2.new(1, 0, 1, 0),
				ZIndex = 2,
				Visible = true,
				[Roact.Ref] = self.viewportRef,
			}),
		})
	end
end
return {
	AvatarViewportComponent = AvatarViewportComponent,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="271">
                  <Properties>
                    <string name="Name">teambutton</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local Workspace = TS.import(script, TS.getModule(script, "@rbxts", "services")).Workspace
local TeamButtonComponent
do
	TeamButtonComponent = Roact.Component:extend("TeamButtonComponent")
	function TeamButtonComponent:init(props)
		props.SelectedEvent:Connect(function(element, selected)
			local _fn = self
			local _ptr = {}
			local _left = "selected"
			local _result
			if element == self then
				_result = selected
			else
				_result = false
			end
			_ptr[_left] = _result
			_ptr.oneSelected = selected
			return _fn:setState(_ptr)
		end)
		if props.StartSelectedIfAlone then
			self:setState({
				selected = props.StartSelectedIfAlone,
				oneSelected = props.StartSelectedIfAlone,
			})
		else
			props.SelectedEvent:Fire(self, false)
		end
	end
	function TeamButtonComponent:render()
		local normalMinimizedSize = Workspace.CurrentCamera and math.ceil(Workspace.CurrentCamera.ViewportSize.X / self.props.NumButtons) or 0
		local selectedMinimizedSize = Workspace.CurrentCamera and math.ceil(Workspace.CurrentCamera.ViewportSize.X / (self.props.NumButtons + 0.5)) or 0
		local maximizedSize = math.ceil(selectedMinimizedSize * 1.5)
		local _ptr = {
			BackgroundColor3 = self.state.selected and Color3.fromRGB(46, 46, 46) or Color3.fromRGB(23, 23, 23),
			BorderSizePixel = 0,
			ClipsDescendants = true,
			Size = UDim2.new(0, self.state.selected and maximizedSize or self.state.oneSelected and selectedMinimizedSize or normalMinimizedSize, 1, 0),
			Text = "",
			AutoButtonColor = false,
			[Roact.Event.MouseButton1Click] = function()
				if self.state.selected then
					self.props.SelectionFinishedEvent:Fire(self.props.Id)
				else
					self.props.SelectedEvent:Fire(self, true)
				end
			end,
		}
		local _ptr_1 = {}
		local _length = #_ptr_1
		local _ptr_2 = {
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 0.25, 0),
		}
		local _result
		if self.state.selected or self.state.oneSelected then
			_result = selectedMinimizedSize >= 350
		else
			_result = normalMinimizedSize >= 350
		end
		_ptr_2.Visible = _result
		_ptr_2.Font = Enum.Font.GothamSemibold
		_ptr_2.Text = self.props.Name
		_ptr_2.TextColor3 = Color3.fromRGB(255, 208, 80)
		_ptr_2.TextScaled = true
		_ptr_2.ZIndex = 0
		_ptr_1.Faction = Roact.createElement("TextLabel", _ptr_2)
		_ptr_1[_length + 1] = self.props.Avatar
		return Roact.createFragment({
			[self.props.Name] = Roact.createElement("TextButton", _ptr, _ptr_1),
		})
	end
end
return {
	TeamButtonComponent = TeamButtonComponent,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="272">
              <Properties>
                <string name="Name">spawn_gui</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v1.2.2
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, TS.getModule(script, "@rbxts", "roact").src)
local ProgressComponent = TS.import(script, script.Parent, "progress").ProgressComponent
local SpawnGuiComponent
do
	SpawnGuiComponent = Roact.Component:extend("SpawnGuiComponent")
	function SpawnGuiComponent:init()
	end
	function SpawnGuiComponent:render()
		return Roact.createFragment({
			StartMenu = Roact.createElement("ScreenGui", {
				IgnoreGuiInset = true,
				ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
			}, {
				Background = Roact.createElement("Frame", {
					BackgroundColor3 = Color3.fromRGB(0, 0, 0),
					BorderSizePixel = 0,
					Size = UDim2.new(1, 0, 1, 0),
				}, {
					Title = Roact.createElement("TextLabel", {
						BackgroundTransparency = 1,
						Font = Enum.Font.SourceSansBold,
						Position = UDim2.new(0, 70, 0, 0),
						Size = UDim2.new(0.3, 0, 0, 36),
						Text = "MOJAVE WASTELANDS",
						TextColor3 = Color3.fromRGB(255, 255, 255),
						TextScaled = true,
						TextSize = 24,
						TextWrapped = true,
						TextXAlignment = Enum.TextXAlignment.Left,
					}),
					Roact.createElement(ProgressComponent, {
						currentScreen = self.props.currentScreen,
						finished = self.props.finished,
					}),
				}),
			}),
		})
	end
end
return {
	SpawnGuiComponent = SpawnGuiComponent,
}
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
      <Item class="Folder" referent="273">
        <Properties>
          <string name="Name">Vendor</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="274">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
    </Properties>
  </Item>
  <SharedStrings>
    <SharedString md5="1B2M2Y8AsgTpgAmY7PhCfg=="></SharedString>
  </SharedStrings>
</roblox>